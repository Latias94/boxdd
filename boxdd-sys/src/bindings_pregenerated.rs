// AUTOGENERATED: pregenerated bindings for docs.rs/offline builds
// To refresh, run tools/update_submodule_and_bindings.py

/* automatically generated by rust-bindgen 0.72.1 */

pub const B2_HASH_INIT: u32 = 5381;
pub const B2_PI: f64 = 3.14159265359;
pub const B2_MAX_POLYGON_VERTICES: u32 = 8;
pub const B2_DEFAULT_CATEGORY_BITS: u32 = 1;
#[doc = " Prototype for user allocation function\n @param size the allocation size in bytes\n @param alignment the required alignment, guaranteed to be a power of 2"]
pub type b2AllocFcn = ::std::option::Option<
    unsafe extern "C" fn(
        size: ::std::os::raw::c_uint,
        alignment: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Prototype for user free function\n @param mem the memory previously allocated through `b2AllocFcn`"]
pub type b2FreeFcn = ::std::option::Option<unsafe extern "C" fn(mem: *mut ::std::os::raw::c_void)>;
#[doc = " Prototype for the user assert callback. Return 0 to skip the debugger break."]
pub type b2AssertFcn = ::std::option::Option<
    unsafe extern "C" fn(
        condition: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
unsafe extern "C" {
    #[doc = " This allows the user to override the allocation functions. These should be\n set during application startup."]
    pub fn b2SetAllocator(allocFcn: b2AllocFcn, freeFcn: b2FreeFcn);
}
unsafe extern "C" {
    #[doc = " @return the total bytes allocated by Box2D"]
    pub fn b2GetByteCount() -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Override the default assert callback\n @param assertFcn a non-null assert callback"]
    pub fn b2SetAssertFcn(assertFcn: b2AssertFcn);
}
#[doc = " Version numbering scheme.\n See https://semver.org/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Version {
    #[doc = " Significant changes"]
    pub major: ::std::os::raw::c_int,
    #[doc = " Incremental changes"]
    pub minor: ::std::os::raw::c_int,
    #[doc = " Bug fixes"]
    pub revision: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Get the current version of Box2D"]
    pub fn b2GetVersion() -> b2Version;
}
unsafe extern "C" {
    pub fn b2InternalAssertFcn(
        condition: *const ::std::os::raw::c_char,
        fileName: *const ::std::os::raw::c_char,
        lineNumber: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the absolute number of system ticks. The value is platform specific."]
    pub fn b2GetTicks() -> u64;
}
unsafe extern "C" {
    #[doc = " Get the milliseconds passed from an initial tick value."]
    pub fn b2GetMilliseconds(ticks: u64) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the milliseconds passed from an initial tick value. Resets the passed in\n value to the current tick value."]
    pub fn b2GetMillisecondsAndReset(ticks: *mut u64) -> f32;
}
unsafe extern "C" {
    #[doc = " Yield to be used in a busy loop."]
    pub fn b2Yield();
}
unsafe extern "C" {
    pub fn b2Hash(hash: u32, data: *const u8, count: ::std::os::raw::c_int) -> u32;
}
#[doc = " 2D vector\n This can be used to represent a point or free vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Vec2 {
    #[doc = " coordinates"]
    pub x: f32,
    #[doc = " coordinates"]
    pub y: f32,
}
#[doc = " Cosine and sine pair\n This uses a custom implementation designed for cross-platform determinism"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2CosSin {
    #[doc = " cosine and sine"]
    pub cosine: f32,
    pub sine: f32,
}
#[doc = " 2D rotation\n This is similar to using a complex number for rotation"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Rot {
    #[doc = " cosine and sine"]
    pub c: f32,
    #[doc = " cosine and sine"]
    pub s: f32,
}
#[doc = " A 2D rigid transform"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Transform {
    pub p: b2Vec2,
    pub q: b2Rot,
}
#[doc = " A 2-by-2 Matrix"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Mat22 {
    #[doc = " columns"]
    pub cx: b2Vec2,
    #[doc = " columns"]
    pub cy: b2Vec2,
}
#[doc = " Axis-aligned bounding box"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2AABB {
    pub lowerBound: b2Vec2,
    pub upperBound: b2Vec2,
}
#[doc = " separation = dot(normal, point) - offset"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Plane {
    pub normal: b2Vec2,
    pub offset: f32,
}
unsafe extern "C" {
    #[doc = " Is this a valid number? Not NaN or infinity."]
    pub fn b2IsValidFloat(a: f32) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a valid vector? Not NaN or infinity."]
    pub fn b2IsValidVec2(v: b2Vec2) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a valid rotation? Not NaN or infinity. Is normalized."]
    pub fn b2IsValidRotation(q: b2Rot) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a valid transform? Not NaN or infinity. Rotation is normalized."]
    pub fn b2IsValidTransform(t: b2Transform) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a valid bounding box? Not Nan or infinity. Upper bound greater than or equal to lower bound."]
    pub fn b2IsValidAABB(aabb: b2AABB) -> bool;
}
unsafe extern "C" {
    #[doc = " Is this a valid plane? Normal is a unit vector. Not Nan or infinity."]
    pub fn b2IsValidPlane(a: b2Plane) -> bool;
}
unsafe extern "C" {
    #[doc = " Compute an approximate arctangent in the range [-pi, pi]\n This is hand coded for cross-platform determinism. The atan2f\n function in the standard library is not cross-platform deterministic.\n\tAccurate to around 0.0023 degrees"]
    pub fn b2Atan2(y: f32, x: f32) -> f32;
}
unsafe extern "C" {
    #[doc = " Compute the cosine and sine of an angle in radians. Implemented\n for cross-platform determinism."]
    pub fn b2ComputeCosSin(radians: f32) -> b2CosSin;
}
unsafe extern "C" {
    #[doc = " Compute the rotation between two unit vectors"]
    pub fn b2ComputeRotationBetweenUnitVectors(v1: b2Vec2, v2: b2Vec2) -> b2Rot;
}
unsafe extern "C" {
    #[doc = " Box2D bases all length units on meters, but you may need different units for your game.\n You can set this value to use different units. This should be done at application startup\n and only modified once. Default value is 1.\n For example, if your game uses pixels for units you can use pixels for all length values\n sent to Box2D. There should be no extra cost. However, Box2D has some internal tolerances\n and thresholds that have been tuned for meters. By calling this function, Box2D is able\n to adjust those tolerances and thresholds to improve accuracy.\n A good rule of thumb is to pass the height of your player character to this function. So\n if your player character is 32 pixels high, then pass 32 to this function. Then you may\n confidently use pixels for all the length values sent to Box2D. All length values returned\n from Box2D will also be pixels because Box2D does not do any scaling internally.\n However, you are now on the hook for coming up with good values for gravity, density, and\n forces.\n @warning This must be modified before any calls to Box2D"]
    pub fn b2SetLengthUnitsPerMeter(lengthUnits: f32);
}
unsafe extern "C" {
    #[doc = " Get the current length units per meter."]
    pub fn b2GetLengthUnitsPerMeter() -> f32;
}
#[doc = " Low level ray cast input data"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2RayCastInput {
    #[doc = " Start point of the ray cast"]
    pub origin: b2Vec2,
    #[doc = " Translation of the ray cast"]
    pub translation: b2Vec2,
    #[doc = " The maximum fraction of the translation to consider, typically 1"]
    pub maxFraction: f32,
}
#[doc = " A distance proxy is used by the GJK algorithm. It encapsulates any shape.\n You can provide between 1 and B2_MAX_POLYGON_VERTICES and a radius."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ShapeProxy {
    #[doc = " The point cloud"]
    pub points: [b2Vec2; 8usize],
    #[doc = " The number of points. Must be greater than 0."]
    pub count: ::std::os::raw::c_int,
    #[doc = " The external radius of the point cloud. May be zero."]
    pub radius: f32,
}
#[doc = " Low level shape cast input in generic form. This allows casting an arbitrary point\n cloud wrap with a radius. For example, a circle is a single point with a non-zero radius.\n A capsule is two points with a non-zero radius. A box is four points with a zero radius."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ShapeCastInput {
    #[doc = " A generic shape"]
    pub proxy: b2ShapeProxy,
    #[doc = " The translation of the shape cast"]
    pub translation: b2Vec2,
    #[doc = " The maximum fraction of the translation to consider, typically 1"]
    pub maxFraction: f32,
    #[doc = " Allow shape cast to encroach when initially touching. This only works if the radius is greater than zero."]
    pub canEncroach: bool,
}
#[doc = " Low level ray cast or shape-cast output data. Returns a zero fraction and normal in the case of initial overlap."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2CastOutput {
    #[doc = " The surface normal at the hit point"]
    pub normal: b2Vec2,
    #[doc = " The surface hit point"]
    pub point: b2Vec2,
    #[doc = " The fraction of the input translation at collision"]
    pub fraction: f32,
    #[doc = " The number of iterations used"]
    pub iterations: ::std::os::raw::c_int,
    #[doc = " Did the cast hit?"]
    pub hit: bool,
}
#[doc = " This holds the mass data computed for a shape."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2MassData {
    #[doc = " The mass of the shape, usually in kilograms."]
    pub mass: f32,
    #[doc = " The position of the shape's centroid relative to the shape's origin."]
    pub center: b2Vec2,
    #[doc = " The rotational inertia of the shape about the shape center."]
    pub rotationalInertia: f32,
}
#[doc = " A solid circle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Circle {
    #[doc = " The local center"]
    pub center: b2Vec2,
    #[doc = " The radius"]
    pub radius: f32,
}
#[doc = " A solid capsule can be viewed as two semicircles connected\n by a rectangle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Capsule {
    #[doc = " Local center of the first semicircle"]
    pub center1: b2Vec2,
    #[doc = " Local center of the second semicircle"]
    pub center2: b2Vec2,
    #[doc = " The radius of the semicircles"]
    pub radius: f32,
}
#[doc = " A solid convex polygon. It is assumed that the interior of the polygon is to\n the left of each edge.\n Polygons have a maximum number of vertices equal to B2_MAX_POLYGON_VERTICES.\n In most cases you should not need many vertices for a convex polygon.\n @warning DO NOT fill this out manually, instead use a helper function like\n b2MakePolygon or b2MakeBox."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Polygon {
    #[doc = " The polygon vertices"]
    pub vertices: [b2Vec2; 8usize],
    #[doc = " The outward normal vectors of the polygon sides"]
    pub normals: [b2Vec2; 8usize],
    #[doc = " The centroid of the polygon"]
    pub centroid: b2Vec2,
    #[doc = " The external radius for rounded polygons"]
    pub radius: f32,
    #[doc = " The number of polygon vertices"]
    pub count: ::std::os::raw::c_int,
}
#[doc = " A line segment with two-sided collision."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Segment {
    #[doc = " The first point"]
    pub point1: b2Vec2,
    #[doc = " The second point"]
    pub point2: b2Vec2,
}
#[doc = " A line segment with one-sided collision. Only collides on the right side.\n Several of these are generated for a chain shape.\n ghost1 -> point1 -> point2 -> ghost2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ChainSegment {
    #[doc = " The tail ghost vertex"]
    pub ghost1: b2Vec2,
    #[doc = " The line segment"]
    pub segment: b2Segment,
    #[doc = " The head ghost vertex"]
    pub ghost2: b2Vec2,
    #[doc = " The owning chain shape index (internal usage only)"]
    pub chainId: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Validate ray cast input data (NaN, etc)"]
    pub fn b2IsValidRay(input: *const b2RayCastInput) -> bool;
}
unsafe extern "C" {
    #[doc = " Make a convex polygon from a convex hull. This will assert if the hull is not valid.\n @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull"]
    pub fn b2MakePolygon(hull: *const b2Hull, radius: f32) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.\n @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull"]
    pub fn b2MakeOffsetPolygon(hull: *const b2Hull, position: b2Vec2, rotation: b2Rot)
    -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.\n @warning Do not manually fill in the hull data, it must come directly from b2ComputeHull"]
    pub fn b2MakeOffsetRoundedPolygon(
        hull: *const b2Hull,
        position: b2Vec2,
        rotation: b2Rot,
        radius: f32,
    ) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make a square polygon, bypassing the need for a convex hull.\n @param halfWidth the half-width"]
    pub fn b2MakeSquare(halfWidth: f32) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make a box (rectangle) polygon, bypassing the need for a convex hull.\n @param halfWidth the half-width (x-axis)\n @param halfHeight the half-height (y-axis)"]
    pub fn b2MakeBox(halfWidth: f32, halfHeight: f32) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make a rounded box, bypassing the need for a convex hull.\n @param halfWidth the half-width (x-axis)\n @param halfHeight the half-height (y-axis)\n @param radius the radius of the rounded extension"]
    pub fn b2MakeRoundedBox(halfWidth: f32, halfHeight: f32, radius: f32) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make an offset box, bypassing the need for a convex hull.\n @param halfWidth the half-width (x-axis)\n @param halfHeight the half-height (y-axis)\n @param center the local center of the box\n @param rotation the local rotation of the box"]
    pub fn b2MakeOffsetBox(
        halfWidth: f32,
        halfHeight: f32,
        center: b2Vec2,
        rotation: b2Rot,
    ) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Make an offset rounded box, bypassing the need for a convex hull.\n @param halfWidth the half-width (x-axis)\n @param halfHeight the half-height (y-axis)\n @param center the local center of the box\n @param rotation the local rotation of the box\n @param radius the radius of the rounded extension"]
    pub fn b2MakeOffsetRoundedBox(
        halfWidth: f32,
        halfHeight: f32,
        center: b2Vec2,
        rotation: b2Rot,
        radius: f32,
    ) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Transform a polygon. This is useful for transferring a shape from one body to another."]
    pub fn b2TransformPolygon(transform: b2Transform, polygon: *const b2Polygon) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Compute mass properties of a circle"]
    pub fn b2ComputeCircleMass(shape: *const b2Circle, density: f32) -> b2MassData;
}
unsafe extern "C" {
    #[doc = " Compute mass properties of a capsule"]
    pub fn b2ComputeCapsuleMass(shape: *const b2Capsule, density: f32) -> b2MassData;
}
unsafe extern "C" {
    #[doc = " Compute mass properties of a polygon"]
    pub fn b2ComputePolygonMass(shape: *const b2Polygon, density: f32) -> b2MassData;
}
unsafe extern "C" {
    #[doc = " Compute the bounding box of a transformed circle"]
    pub fn b2ComputeCircleAABB(shape: *const b2Circle, transform: b2Transform) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Compute the bounding box of a transformed capsule"]
    pub fn b2ComputeCapsuleAABB(shape: *const b2Capsule, transform: b2Transform) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Compute the bounding box of a transformed polygon"]
    pub fn b2ComputePolygonAABB(shape: *const b2Polygon, transform: b2Transform) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Compute the bounding box of a transformed line segment"]
    pub fn b2ComputeSegmentAABB(shape: *const b2Segment, transform: b2Transform) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Test a point for overlap with a circle in local space"]
    pub fn b2PointInCircle(shape: *const b2Circle, point: b2Vec2) -> bool;
}
unsafe extern "C" {
    #[doc = " Test a point for overlap with a capsule in local space"]
    pub fn b2PointInCapsule(shape: *const b2Capsule, point: b2Vec2) -> bool;
}
unsafe extern "C" {
    #[doc = " Test a point for overlap with a convex polygon in local space"]
    pub fn b2PointInPolygon(shape: *const b2Polygon, point: b2Vec2) -> bool;
}
unsafe extern "C" {
    #[doc = " Ray cast versus circle shape in local space."]
    pub fn b2RayCastCircle(shape: *const b2Circle, input: *const b2RayCastInput) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Ray cast versus capsule shape in local space."]
    pub fn b2RayCastCapsule(shape: *const b2Capsule, input: *const b2RayCastInput) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Ray cast versus segment shape in local space. Optionally treat the segment as one-sided with hits from\n the left side being treated as a miss."]
    pub fn b2RayCastSegment(
        shape: *const b2Segment,
        input: *const b2RayCastInput,
        oneSided: bool,
    ) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Ray cast versus polygon shape in local space."]
    pub fn b2RayCastPolygon(shape: *const b2Polygon, input: *const b2RayCastInput) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Shape cast versus a circle."]
    pub fn b2ShapeCastCircle(
        shape: *const b2Circle,
        input: *const b2ShapeCastInput,
    ) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Shape cast versus a capsule."]
    pub fn b2ShapeCastCapsule(
        shape: *const b2Capsule,
        input: *const b2ShapeCastInput,
    ) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Shape cast versus a line segment."]
    pub fn b2ShapeCastSegment(
        shape: *const b2Segment,
        input: *const b2ShapeCastInput,
    ) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Shape cast versus a convex polygon."]
    pub fn b2ShapeCastPolygon(
        shape: *const b2Polygon,
        input: *const b2ShapeCastInput,
    ) -> b2CastOutput;
}
#[doc = " A convex hull. Used to create convex polygons.\n @warning Do not modify these values directly, instead use b2ComputeHull()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Hull {
    #[doc = " The final points of the hull"]
    pub points: [b2Vec2; 8usize],
    #[doc = " The number of points"]
    pub count: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Compute the convex hull of a set of points. Returns an empty hull if it fails.\n Some failure cases:\n - all points very close together\n - all points on a line\n - less than 3 points\n - more than B2_MAX_POLYGON_VERTICES points\n This welds close points and removes collinear points.\n @warning Do not modify a hull once it has been computed"]
    pub fn b2ComputeHull(points: *const b2Vec2, count: ::std::os::raw::c_int) -> b2Hull;
}
unsafe extern "C" {
    #[doc = " This determines if a hull is valid. Checks for:\n - convexity\n - collinear points\n This is expensive and should not be called at runtime."]
    pub fn b2ValidateHull(hull: *const b2Hull) -> bool;
}
#[doc = " Result of computing the distance between two line segments"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SegmentDistanceResult {
    #[doc = " The closest point on the first segment"]
    pub closest1: b2Vec2,
    #[doc = " The closest point on the second segment"]
    pub closest2: b2Vec2,
    #[doc = " The barycentric coordinate on the first segment"]
    pub fraction1: f32,
    #[doc = " The barycentric coordinate on the second segment"]
    pub fraction2: f32,
    #[doc = " The squared distance between the closest points"]
    pub distanceSquared: f32,
}
unsafe extern "C" {
    #[doc = " Compute the distance between two line segments, clamping at the end points if needed."]
    pub fn b2SegmentDistance(
        p1: b2Vec2,
        q1: b2Vec2,
        p2: b2Vec2,
        q2: b2Vec2,
    ) -> b2SegmentDistanceResult;
}
#[doc = " Used to warm start the GJK simplex. If you call this function multiple times with nearby\n transforms this might improve performance. Otherwise you can zero initialize this.\n The distance cache must be initialized to zero on the first call.\n Users should generally just zero initialize this structure for each call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SimplexCache {
    #[doc = " The number of stored simplex points"]
    pub count: u16,
    #[doc = " The cached simplex indices on shape A"]
    pub indexA: [u8; 3usize],
    #[doc = " The cached simplex indices on shape B"]
    pub indexB: [u8; 3usize],
}
#[doc = " Input for b2ShapeDistance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2DistanceInput {
    #[doc = " The proxy for shape A"]
    pub proxyA: b2ShapeProxy,
    #[doc = " The proxy for shape B"]
    pub proxyB: b2ShapeProxy,
    #[doc = " The world transform for shape A"]
    pub transformA: b2Transform,
    #[doc = " The world transform for shape B"]
    pub transformB: b2Transform,
    #[doc = " Should the proxy radius be considered?"]
    pub useRadii: bool,
}
#[doc = " Output for b2ShapeDistance"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2DistanceOutput {
    #[doc = "< Closest point on shapeA"]
    pub pointA: b2Vec2,
    #[doc = "< Closest point on shapeB"]
    pub pointB: b2Vec2,
    #[doc = "< Normal vector that points from A to B. Invalid if distance is zero."]
    pub normal: b2Vec2,
    #[doc = "< The final distance, zero if overlapped"]
    pub distance: f32,
    #[doc = "< Number of GJK iterations used"]
    pub iterations: ::std::os::raw::c_int,
    #[doc = "< The number of simplexes stored in the simplex array"]
    pub simplexCount: ::std::os::raw::c_int,
}
#[doc = " Simplex vertex for debugging the GJK algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SimplexVertex {
    #[doc = "< support point in proxyA"]
    pub wA: b2Vec2,
    #[doc = "< support point in proxyB"]
    pub wB: b2Vec2,
    #[doc = "< wB - wA"]
    pub w: b2Vec2,
    #[doc = "< barycentric coordinate for closest point"]
    pub a: f32,
    #[doc = "< wA index"]
    pub indexA: ::std::os::raw::c_int,
    #[doc = "< wB index"]
    pub indexB: ::std::os::raw::c_int,
}
#[doc = " Simplex from the GJK algorithm"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Simplex {
    #[doc = "< vertices"]
    pub v1: b2SimplexVertex,
    #[doc = "< vertices"]
    pub v2: b2SimplexVertex,
    #[doc = "< vertices"]
    pub v3: b2SimplexVertex,
    #[doc = "< number of valid vertices"]
    pub count: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Compute the closest points between two shapes represented as point clouds.\n b2SimplexCache cache is input/output. On the first call set b2SimplexCache.count to zero.\n The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these."]
    pub fn b2ShapeDistance(
        input: *const b2DistanceInput,
        cache: *mut b2SimplexCache,
        simplexes: *mut b2Simplex,
        simplexCapacity: ::std::os::raw::c_int,
    ) -> b2DistanceOutput;
}
#[doc = " Input parameters for b2ShapeCast"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ShapeCastPairInput {
    #[doc = "< The proxy for shape A"]
    pub proxyA: b2ShapeProxy,
    #[doc = "< The proxy for shape B"]
    pub proxyB: b2ShapeProxy,
    #[doc = "< The world transform for shape A"]
    pub transformA: b2Transform,
    #[doc = "< The world transform for shape B"]
    pub transformB: b2Transform,
    #[doc = "< The translation of shape B"]
    pub translationB: b2Vec2,
    #[doc = "< The fraction of the translation to consider, typically 1"]
    pub maxFraction: f32,
    #[doc = "< Allows shapes with a radius to move slightly closer if already touching"]
    pub canEncroach: bool,
}
unsafe extern "C" {
    #[doc = " Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.\n Initially touching shapes are treated as a miss."]
    pub fn b2ShapeCast(input: *const b2ShapeCastPairInput) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Make a proxy for use in overlap, shape cast, and related functions. This is a deep copy of the points."]
    pub fn b2MakeProxy(
        points: *const b2Vec2,
        count: ::std::os::raw::c_int,
        radius: f32,
    ) -> b2ShapeProxy;
}
unsafe extern "C" {
    #[doc = " Make a proxy with a transform. This is a deep copy of the points."]
    pub fn b2MakeOffsetProxy(
        points: *const b2Vec2,
        count: ::std::os::raw::c_int,
        radius: f32,
        position: b2Vec2,
        rotation: b2Rot,
    ) -> b2ShapeProxy;
}
#[doc = " This describes the motion of a body/shape for TOI computation. Shapes are defined with respect to the body origin,\n which may not coincide with the center of mass. However, to support dynamics we must interpolate the center of mass\n position."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Sweep {
    #[doc = "< Local center of mass position"]
    pub localCenter: b2Vec2,
    #[doc = "< Starting center of mass world position"]
    pub c1: b2Vec2,
    #[doc = "< Ending center of mass world position"]
    pub c2: b2Vec2,
    #[doc = "< Starting world rotation"]
    pub q1: b2Rot,
    #[doc = "< Ending world rotation"]
    pub q2: b2Rot,
}
unsafe extern "C" {
    #[doc = " Evaluate the transform sweep at a specific time."]
    pub fn b2GetSweepTransform(sweep: *const b2Sweep, time: f32) -> b2Transform;
}
#[doc = " Time of impact input"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2TOIInput {
    #[doc = "< The proxy for shape A"]
    pub proxyA: b2ShapeProxy,
    #[doc = "< The proxy for shape B"]
    pub proxyB: b2ShapeProxy,
    #[doc = "< The movement of shape A"]
    pub sweepA: b2Sweep,
    #[doc = "< The movement of shape B"]
    pub sweepB: b2Sweep,
    #[doc = "< Defines the sweep interval [0, maxFraction]"]
    pub maxFraction: f32,
}
pub const b2TOIState_b2_toiStateUnknown: b2TOIState = 0;
pub const b2TOIState_b2_toiStateFailed: b2TOIState = 1;
pub const b2TOIState_b2_toiStateOverlapped: b2TOIState = 2;
pub const b2TOIState_b2_toiStateHit: b2TOIState = 3;
pub const b2TOIState_b2_toiStateSeparated: b2TOIState = 4;
#[doc = " Describes the TOI output"]
pub type b2TOIState = ::std::os::raw::c_int;
#[doc = " Time of impact output"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2TOIOutput {
    #[doc = " The type of result"]
    pub state: b2TOIState,
    #[doc = " The hit point"]
    pub point: b2Vec2,
    #[doc = " The hit normal"]
    pub normal: b2Vec2,
    #[doc = " The sweep time of the collision"]
    pub fraction: f32,
}
unsafe extern "C" {
    #[doc = " Compute the upper bound on time before two shapes penetrate. Time is represented as\n a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,\n non-tunneling collisions. If you change the time interval, you should call this function\n again."]
    pub fn b2TimeOfImpact(input: *const b2TOIInput) -> b2TOIOutput;
}
#[doc = " A manifold point is a contact point belonging to a contact manifold.\n It holds details related to the geometry and dynamics of the contact points.\n Box2D uses speculative collision so some contact points may be separated.\n You may use the totalNormalImpulse to determine if there was an interaction during\n the time step."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ManifoldPoint {
    #[doc = " Location of the contact point in world space. Subject to precision loss at large coordinates.\n @note Should only be used for debugging."]
    pub point: b2Vec2,
    #[doc = " Location of the contact point relative to shapeA's origin in world space\n @note When used internally to the Box2D solver, this is relative to the body center of mass."]
    pub anchorA: b2Vec2,
    #[doc = " Location of the contact point relative to shapeB's origin in world space\n @note When used internally to the Box2D solver, this is relative to the body center of mass."]
    pub anchorB: b2Vec2,
    #[doc = " The separation of the contact point, negative if penetrating"]
    pub separation: f32,
    #[doc = " The impulse along the manifold normal vector."]
    pub normalImpulse: f32,
    #[doc = " The friction impulse"]
    pub tangentImpulse: f32,
    #[doc = " The total normal impulse applied across sub-stepping and restitution. This is important\n to identify speculative contact points that had an interaction in the time step."]
    pub totalNormalImpulse: f32,
    #[doc = " Relative normal velocity pre-solve. Used for hit events. If the normal impulse is\n zero then there was no hit. Negative means shapes are approaching."]
    pub normalVelocity: f32,
    #[doc = " Uniquely identifies a contact point between two shapes"]
    pub id: u16,
    #[doc = " Did this contact point exist the previous step?"]
    pub persisted: bool,
}
#[doc = " A contact manifold describes the contact points between colliding shapes.\n @note Box2D uses speculative collision so some contact points may be separated."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Manifold {
    #[doc = " The unit normal vector in world space, points from shape A to bodyB"]
    pub normal: b2Vec2,
    #[doc = " Angular impulse applied for rolling resistance. N * m * s = kg * m^2 / s"]
    pub rollingImpulse: f32,
    #[doc = " The manifold points, up to two are possible in 2D"]
    pub points: [b2ManifoldPoint; 2usize],
    #[doc = " The number of contacts points, will be 0, 1, or 2"]
    pub pointCount: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between two circles"]
    pub fn b2CollideCircles(
        circleA: *const b2Circle,
        xfA: b2Transform,
        circleB: *const b2Circle,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a capsule and circle"]
    pub fn b2CollideCapsuleAndCircle(
        capsuleA: *const b2Capsule,
        xfA: b2Transform,
        circleB: *const b2Circle,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between an segment and a circle"]
    pub fn b2CollideSegmentAndCircle(
        segmentA: *const b2Segment,
        xfA: b2Transform,
        circleB: *const b2Circle,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a polygon and a circle"]
    pub fn b2CollidePolygonAndCircle(
        polygonA: *const b2Polygon,
        xfA: b2Transform,
        circleB: *const b2Circle,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a capsule and circle"]
    pub fn b2CollideCapsules(
        capsuleA: *const b2Capsule,
        xfA: b2Transform,
        capsuleB: *const b2Capsule,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between an segment and a capsule"]
    pub fn b2CollideSegmentAndCapsule(
        segmentA: *const b2Segment,
        xfA: b2Transform,
        capsuleB: *const b2Capsule,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a polygon and capsule"]
    pub fn b2CollidePolygonAndCapsule(
        polygonA: *const b2Polygon,
        xfA: b2Transform,
        capsuleB: *const b2Capsule,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between two polygons"]
    pub fn b2CollidePolygons(
        polygonA: *const b2Polygon,
        xfA: b2Transform,
        polygonB: *const b2Polygon,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between an segment and a polygon"]
    pub fn b2CollideSegmentAndPolygon(
        segmentA: *const b2Segment,
        xfA: b2Transform,
        polygonB: *const b2Polygon,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a chain segment and a circle"]
    pub fn b2CollideChainSegmentAndCircle(
        segmentA: *const b2ChainSegment,
        xfA: b2Transform,
        circleB: *const b2Circle,
        xfB: b2Transform,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a chain segment and a capsule"]
    pub fn b2CollideChainSegmentAndCapsule(
        segmentA: *const b2ChainSegment,
        xfA: b2Transform,
        capsuleB: *const b2Capsule,
        xfB: b2Transform,
        cache: *mut b2SimplexCache,
    ) -> b2Manifold;
}
unsafe extern "C" {
    #[doc = " Compute the contact manifold between a chain segment and a rounded polygon"]
    pub fn b2CollideChainSegmentAndPolygon(
        segmentA: *const b2ChainSegment,
        xfA: b2Transform,
        polygonB: *const b2Polygon,
        xfB: b2Transform,
        cache: *mut b2SimplexCache,
    ) -> b2Manifold;
}
#[doc = " The dynamic tree structure. This should be considered private data.\n It is placed here for performance reasons."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2DynamicTree {
    #[doc = " The tree nodes"]
    pub nodes: *mut b2TreeNode,
    #[doc = " The root index"]
    pub root: ::std::os::raw::c_int,
    #[doc = " The number of nodes"]
    pub nodeCount: ::std::os::raw::c_int,
    #[doc = " The allocated node space"]
    pub nodeCapacity: ::std::os::raw::c_int,
    #[doc = " Node free list"]
    pub freeList: ::std::os::raw::c_int,
    #[doc = " Number of proxies created"]
    pub proxyCount: ::std::os::raw::c_int,
    #[doc = " Leaf indices for rebuild"]
    pub leafIndices: *mut ::std::os::raw::c_int,
    #[doc = " Leaf bounding boxes for rebuild"]
    pub leafBoxes: *mut b2AABB,
    #[doc = " Leaf bounding box centers for rebuild"]
    pub leafCenters: *mut b2Vec2,
    #[doc = " Bins for sorting during rebuild"]
    pub binIndices: *mut ::std::os::raw::c_int,
    #[doc = " Allocated space for rebuilding"]
    pub rebuildCapacity: ::std::os::raw::c_int,
}
#[doc = " These are performance results returned by dynamic tree queries."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2TreeStats {
    #[doc = " Number of internal nodes visited during the query"]
    pub nodeVisits: ::std::os::raw::c_int,
    #[doc = " Number of leaf nodes visited during the query"]
    pub leafVisits: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Constructing the tree initializes the node pool."]
    pub fn b2DynamicTree_Create() -> b2DynamicTree;
}
unsafe extern "C" {
    #[doc = " Destroy the tree, freeing the node pool."]
    pub fn b2DynamicTree_Destroy(tree: *mut b2DynamicTree);
}
unsafe extern "C" {
    #[doc = " Create a proxy. Provide an AABB and a userData value."]
    pub fn b2DynamicTree_CreateProxy(
        tree: *mut b2DynamicTree,
        aabb: b2AABB,
        categoryBits: u64,
        userData: u64,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Destroy a proxy. This asserts if the id is invalid."]
    pub fn b2DynamicTree_DestroyProxy(tree: *mut b2DynamicTree, proxyId: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Move a proxy to a new AABB by removing and reinserting into the tree."]
    pub fn b2DynamicTree_MoveProxy(
        tree: *mut b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
        aabb: b2AABB,
    );
}
unsafe extern "C" {
    #[doc = " Enlarge a proxy and enlarge ancestors as necessary."]
    pub fn b2DynamicTree_EnlargeProxy(
        tree: *mut b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
        aabb: b2AABB,
    );
}
unsafe extern "C" {
    #[doc = " Modify the category bits on a proxy. This is an expensive operation."]
    pub fn b2DynamicTree_SetCategoryBits(
        tree: *mut b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
        categoryBits: u64,
    );
}
unsafe extern "C" {
    #[doc = " Get the category bits on a proxy."]
    pub fn b2DynamicTree_GetCategoryBits(
        tree: *mut b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
    ) -> u64;
}
#[doc = " This function receives proxies found in the AABB query.\n @return true if the query should continue"]
pub type b2TreeQueryCallbackFcn = ::std::option::Option<
    unsafe extern "C" fn(
        proxyId: ::std::os::raw::c_int,
        userData: u64,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
unsafe extern "C" {
    #[doc = " Query an AABB for overlapping proxies. The callback class is called for each proxy that overlaps the supplied AABB.\n\t@return performance data"]
    pub fn b2DynamicTree_Query(
        tree: *const b2DynamicTree,
        aabb: b2AABB,
        maskBits: u64,
        callback: b2TreeQueryCallbackFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Query an AABB for overlapping proxies. The callback class is called for each proxy that overlaps the supplied AABB.\n No filtering is performed.\n\t@return performance data"]
    pub fn b2DynamicTree_QueryAll(
        tree: *const b2DynamicTree,
        aabb: b2AABB,
        callback: b2TreeQueryCallbackFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
#[doc = " This function receives clipped ray cast input for a proxy. The function\n returns the new ray fraction.\n - return a value of 0 to terminate the ray cast\n - return a value less than input->maxFraction to clip the ray\n - return a value of input->maxFraction to continue the ray cast without clipping"]
pub type b2TreeRayCastCallbackFcn = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const b2RayCastInput,
        proxyId: ::std::os::raw::c_int,
        userData: u64,
        context: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
unsafe extern "C" {
    #[doc = " Ray cast against the proxies in the tree. This relies on the callback\n to perform a exact ray cast in the case were the proxy contains a shape.\n The callback also performs the any collision filtering. This has performance\n roughly equal to k * log(n), where k is the number of collisions and n is the\n number of proxies in the tree.\n Bit-wise filtering using mask bits can greatly improve performance in some scenarios.\n\tHowever, this filtering may be approximate, so the user should still apply filtering to results.\n @param tree the dynamic tree to ray cast\n @param input the ray cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1)\n @param maskBits mask bit hint: `bool accept = (maskBits & node->categoryBits) != 0;`\n @param callback a callback class that is called for each proxy that is hit by the ray\n @param context user context that is passed to the callback\n\t@return performance data"]
    pub fn b2DynamicTree_RayCast(
        tree: *const b2DynamicTree,
        input: *const b2RayCastInput,
        maskBits: u64,
        callback: b2TreeRayCastCallbackFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
#[doc = " This function receives clipped ray cast input for a proxy. The function\n returns the new ray fraction.\n - return a value of 0 to terminate the ray cast\n - return a value less than input->maxFraction to clip the ray\n - return a value of input->maxFraction to continue the ray cast without clipping"]
pub type b2TreeShapeCastCallbackFcn = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const b2ShapeCastInput,
        proxyId: ::std::os::raw::c_int,
        userData: u64,
        context: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
unsafe extern "C" {
    #[doc = " Ray cast against the proxies in the tree. This relies on the callback\n to perform a exact ray cast in the case were the proxy contains a shape.\n The callback also performs the any collision filtering. This has performance\n roughly equal to k * log(n), where k is the number of collisions and n is the\n number of proxies in the tree.\n @param tree the dynamic tree to ray cast\n @param input the ray cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).\n @param maskBits filter bits: `bool accept = (maskBits & node->categoryBits) != 0;`\n @param callback a callback class that is called for each proxy that is hit by the shape\n @param context user context that is passed to the callback\n\t@return performance data"]
    pub fn b2DynamicTree_ShapeCast(
        tree: *const b2DynamicTree,
        input: *const b2ShapeCastInput,
        maskBits: u64,
        callback: b2TreeShapeCastCallbackFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Get the height of the binary tree."]
    pub fn b2DynamicTree_GetHeight(tree: *const b2DynamicTree) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the ratio of the sum of the node areas to the root area."]
    pub fn b2DynamicTree_GetAreaRatio(tree: *const b2DynamicTree) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the bounding box that contains the entire tree"]
    pub fn b2DynamicTree_GetRootBounds(tree: *const b2DynamicTree) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Get the number of proxies created"]
    pub fn b2DynamicTree_GetProxyCount(tree: *const b2DynamicTree) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Rebuild the tree while retaining subtrees that haven't changed. Returns the number of boxes sorted."]
    pub fn b2DynamicTree_Rebuild(
        tree: *mut b2DynamicTree,
        fullBuild: bool,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of bytes used by this tree"]
    pub fn b2DynamicTree_GetByteCount(tree: *const b2DynamicTree) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get proxy user data"]
    pub fn b2DynamicTree_GetUserData(
        tree: *const b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
    ) -> u64;
}
unsafe extern "C" {
    #[doc = " Get the AABB of a proxy"]
    pub fn b2DynamicTree_GetAABB(
        tree: *const b2DynamicTree,
        proxyId: ::std::os::raw::c_int,
    ) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Validate this tree. For testing."]
    pub fn b2DynamicTree_Validate(tree: *const b2DynamicTree);
}
unsafe extern "C" {
    #[doc = " Validate this tree has no enlarged AABBs. For testing."]
    pub fn b2DynamicTree_ValidateNoEnlarged(tree: *const b2DynamicTree);
}
#[doc = " These are the collision planes returned from b2World_CollideMover"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2PlaneResult {
    #[doc = " The collision plane between the mover and a convex shape"]
    pub plane: b2Plane,
    pub point: b2Vec2,
    #[doc = " Did the collision register a hit? If not this plane should be ignored."]
    pub hit: bool,
}
#[doc = " These are collision planes that can be fed to b2SolvePlanes. Normally\n this is assembled by the user from plane results in b2PlaneResult"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2CollisionPlane {
    #[doc = " The collision plane between the mover and some shape"]
    pub plane: b2Plane,
    #[doc = " Setting this to FLT_MAX makes the plane as rigid as possible. Lower values can\n make the plane collision soft. Usually in meters."]
    pub pushLimit: f32,
    #[doc = " The push on the mover determined by b2SolvePlanes. Usually in meters."]
    pub push: f32,
    #[doc = " Indicates if b2ClipVector should clip against this plane. Should be false for soft collision."]
    pub clipVelocity: bool,
}
#[doc = " Result returned by b2SolvePlanes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2PlaneSolverResult {
    #[doc = " The translation of the mover"]
    pub translation: b2Vec2,
    #[doc = " The number of iterations used by the plane solver. For diagnostics."]
    pub iterationCount: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Solves the position of a mover that satisfies the given collision planes.\n @param targetDelta the desired movement from the position used to generate the collision planes\n @param planes the collision planes\n @param count the number of collision planes"]
    pub fn b2SolvePlanes(
        targetDelta: b2Vec2,
        planes: *mut b2CollisionPlane,
        count: ::std::os::raw::c_int,
    ) -> b2PlaneSolverResult;
}
unsafe extern "C" {
    #[doc = " Clips the velocity against the given collision planes. Planes with zero push or clipVelocity\n set to false are skipped."]
    pub fn b2ClipVector(
        vector: b2Vec2,
        planes: *const b2CollisionPlane,
        count: ::std::os::raw::c_int,
    ) -> b2Vec2;
}
#[doc = " World id references a world instance. This should be treated as an opaque handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2WorldId {
    pub index1: u16,
    pub generation: u16,
}
#[doc = " Body id references a body instance. This should be treated as an opaque handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2BodyId {
    pub index1: i32,
    pub world0: u16,
    pub generation: u16,
}
#[doc = " Shape id references a shape instance. This should be treated as an opaque handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ShapeId {
    pub index1: i32,
    pub world0: u16,
    pub generation: u16,
}
#[doc = " Chain id references a chain instances. This should be treated as an opaque handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ChainId {
    pub index1: i32,
    pub world0: u16,
    pub generation: u16,
}
#[doc = " Joint id references a joint instance. This should be treated as an opaque handle."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2JointId {
    pub index1: i32,
    pub world0: u16,
    pub generation: u16,
}
#[doc = " Contact id references a contact instance. This should be treated as an opaque handled."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactId {
    pub index1: i32,
    pub world0: u16,
    pub padding: i16,
    pub generation: u32,
}
#[doc = " Task interface\n This is prototype for a Box2D task. Your task system is expected to invoke the Box2D task with these arguments.\n The task spans a range of the parallel-for: [startIndex, endIndex)\n The worker index must correctly identify each worker in the user thread pool, expected in [0, workerCount).\n A worker must only exist on only one thread at a time and is analogous to the thread index.\n The task context is the context pointer sent from Box2D when it is enqueued.\n The startIndex and endIndex are expected in the range [0, itemCount) where itemCount is the argument to b2EnqueueTaskCallback\n below. Box2D expects startIndex < endIndex and will execute a loop like this:\n\n @code{.c}\n for (int i = startIndex; i < endIndex; ++i)\n {\n \tDoWork();\n }\n @endcode\n @ingroup world"]
pub type b2TaskCallback = ::std::option::Option<
    unsafe extern "C" fn(
        startIndex: ::std::os::raw::c_int,
        endIndex: ::std::os::raw::c_int,
        workerIndex: u32,
        taskContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " These functions can be provided to Box2D to invoke a task system. These are designed to work well with enkiTS.\n Returns a pointer to the user's task object. May be nullptr. A nullptr indicates to Box2D that the work was executed\n serially within the callback and there is no need to call b2FinishTaskCallback.\n The itemCount is the number of Box2D work items that are to be partitioned among workers by the user's task system.\n This is essentially a parallel-for. The minRange parameter is a suggestion of the minimum number of items to assign\n per worker to reduce overhead. For example, suppose the task is small and that itemCount is 16. A minRange of 8 suggests\n that your task system should split the work items among just two workers, even if you have more available.\n In general the range [startIndex, endIndex) send to b2TaskCallback should obey:\n endIndex - startIndex >= minRange\n The exception of course is when itemCount < minRange.\n @ingroup world"]
pub type b2EnqueueTaskCallback = ::std::option::Option<
    unsafe extern "C" fn(
        task: b2TaskCallback,
        itemCount: ::std::os::raw::c_int,
        minRange: ::std::os::raw::c_int,
        taskContext: *mut ::std::os::raw::c_void,
        userContext: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void,
>;
#[doc = " Finishes a user task object that wraps a Box2D task.\n @ingroup world"]
pub type b2FinishTaskCallback = ::std::option::Option<
    unsafe extern "C" fn(
        userTask: *mut ::std::os::raw::c_void,
        userContext: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " Optional friction mixing callback. This intentionally provides no context objects because this is called\n from a worker thread.\n @warning This function should not attempt to modify Box2D state or user application state.\n @ingroup world"]
pub type b2FrictionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        frictionA: f32,
        userMaterialIdA: u64,
        frictionB: f32,
        userMaterialIdB: u64,
    ) -> f32,
>;
#[doc = " Optional restitution mixing callback. This intentionally provides no context objects because this is called\n from a worker thread.\n @warning This function should not attempt to modify Box2D state or user application state.\n @ingroup world"]
pub type b2RestitutionCallback = ::std::option::Option<
    unsafe extern "C" fn(
        restitutionA: f32,
        userMaterialIdA: u64,
        restitutionB: f32,
        userMaterialIdB: u64,
    ) -> f32,
>;
#[doc = " Result from b2World_RayCastClosest\n If there is initial overlap the fraction and normal will be zero while the point is an arbitrary point in the overlap region.\n @ingroup world"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2RayResult {
    pub shapeId: b2ShapeId,
    pub point: b2Vec2,
    pub normal: b2Vec2,
    pub fraction: f32,
    pub nodeVisits: ::std::os::raw::c_int,
    pub leafVisits: ::std::os::raw::c_int,
    pub hit: bool,
}
#[doc = " World definition used to create a simulation world.\n Must be initialized using b2DefaultWorldDef().\n @ingroup world"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2WorldDef {
    #[doc = " Gravity vector. Box2D has no up-vector defined."]
    pub gravity: b2Vec2,
    #[doc = " Restitution speed threshold, usually in m/s. Collisions above this\n speed have restitution applied (will bounce)."]
    pub restitutionThreshold: f32,
    #[doc = " Threshold speed for hit events. Usually meters per second."]
    pub hitEventThreshold: f32,
    #[doc = " Contact stiffness. Cycles per second. Increasing this increases the speed of overlap recovery, but can introduce jitter."]
    pub contactHertz: f32,
    #[doc = " Contact bounciness. Non-dimensional. You can speed up overlap recovery by decreasing this with\n the trade-off that overlap resolution becomes more energetic."]
    pub contactDampingRatio: f32,
    #[doc = " This parameter controls how fast overlap is resolved and usually has units of meters per second. This only\n puts a cap on the resolution speed. The resolution speed is increased by increasing the hertz and/or\n decreasing the damping ratio."]
    pub contactSpeed: f32,
    #[doc = " Maximum linear speed. Usually meters per second."]
    pub maximumLinearSpeed: f32,
    #[doc = " Optional mixing callback for friction. The default uses sqrt(frictionA * frictionB)."]
    pub frictionCallback: b2FrictionCallback,
    #[doc = " Optional mixing callback for restitution. The default uses max(restitutionA, restitutionB)."]
    pub restitutionCallback: b2RestitutionCallback,
    #[doc = " Can bodies go to sleep to improve performance"]
    pub enableSleep: bool,
    #[doc = " Enable continuous collision"]
    pub enableContinuous: bool,
    #[doc = " Contact softening when mass ratios are large. Experimental."]
    pub enableContactSoftening: bool,
    #[doc = " Number of workers to use with the provided task system. Box2D performs best when using only\n performance cores and accessing a single L2 cache. Efficiency cores and hyper-threading provide\n little benefit and may even harm performance.\n @note Box2D does not create threads. This is the number of threads your applications has created\n that you are allocating to b2World_Step.\n @warning Do not modify the default value unless you are also providing a task system and providing\n task callbacks (enqueueTask and finishTask)."]
    pub workerCount: ::std::os::raw::c_int,
    #[doc = " Function to spawn tasks"]
    pub enqueueTask: b2EnqueueTaskCallback,
    #[doc = " Function to finish a task"]
    pub finishTask: b2FinishTaskCallback,
    #[doc = " User context that is provided to enqueueTask and finishTask"]
    pub userTaskContext: *mut ::std::os::raw::c_void,
    #[doc = " User data"]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your world definition\n @ingroup world"]
    pub fn b2DefaultWorldDef() -> b2WorldDef;
}
#[doc = " zero mass, zero velocity, may be manually moved"]
pub const b2BodyType_b2_staticBody: b2BodyType = 0;
#[doc = " zero mass, velocity set by user, moved by solver"]
pub const b2BodyType_b2_kinematicBody: b2BodyType = 1;
#[doc = " positive mass, velocity determined by forces, moved by solver"]
pub const b2BodyType_b2_dynamicBody: b2BodyType = 2;
#[doc = " number of body types"]
pub const b2BodyType_b2_bodyTypeCount: b2BodyType = 3;
#[doc = " The body simulation type.\n Each body is one of these three types. The type determines how the body behaves in the simulation.\n @ingroup body"]
pub type b2BodyType = ::std::os::raw::c_int;
#[doc = " Motion locks to restrict the body movement"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2MotionLocks {
    #[doc = " Prevent translation along the x-axis"]
    pub linearX: bool,
    #[doc = " Prevent translation along the y-axis"]
    pub linearY: bool,
    #[doc = " Prevent rotation around the z-axis"]
    pub angularZ: bool,
}
#[doc = " A body definition holds all the data needed to construct a rigid body.\n You can safely re-use body definitions. Shapes are added to a body after construction.\n Body definitions are temporary objects used to bundle creation parameters.\n Must be initialized using b2DefaultBodyDef().\n @ingroup body"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2BodyDef {
    #[doc = " The body type: static, kinematic, or dynamic."]
    pub type_: b2BodyType,
    #[doc = " The initial world position of the body. Bodies should be created with the desired position.\n @note Creating bodies at the origin and then moving them nearly doubles the cost of body creation, especially\n if the body is moved after shapes have been added."]
    pub position: b2Vec2,
    #[doc = " The initial world rotation of the body. Use b2MakeRot() if you have an angle."]
    pub rotation: b2Rot,
    #[doc = " The initial linear velocity of the body's origin. Usually in meters per second."]
    pub linearVelocity: b2Vec2,
    #[doc = " The initial angular velocity of the body. Radians per second."]
    pub angularVelocity: f32,
    #[doc = " Linear damping is used to reduce the linear velocity. The damping parameter\n can be larger than 1 but the damping effect becomes sensitive to the\n time step when the damping parameter is large.\n Generally linear damping is undesirable because it makes objects move slowly\n as if they are floating."]
    pub linearDamping: f32,
    #[doc = " Angular damping is used to reduce the angular velocity. The damping parameter\n can be larger than 1.0f but the damping effect becomes sensitive to the\n time step when the damping parameter is large.\n Angular damping can be use slow down rotating bodies."]
    pub angularDamping: f32,
    #[doc = " Scale the gravity applied to this body. Non-dimensional."]
    pub gravityScale: f32,
    #[doc = " Sleep speed threshold, default is 0.05 meters per second"]
    pub sleepThreshold: f32,
    #[doc = " Optional body name for debugging. Up to 31 characters (excluding null termination)"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " Use this to store application specific body data."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " Motions locks to restrict linear and angular movement.\n Caution: may lead to softer constraints along the locked direction"]
    pub motionLocks: b2MotionLocks,
    #[doc = " Set this flag to false if this body should never fall asleep."]
    pub enableSleep: bool,
    #[doc = " Is this body initially awake or sleeping?"]
    pub isAwake: bool,
    #[doc = " Treat this body as high speed object that performs continuous collision detection\n against dynamic and kinematic bodies, but not other bullet bodies.\n @warning Bullets should be used sparingly. They are not a solution for general dynamic-versus-dynamic\n continuous collision."]
    pub isBullet: bool,
    #[doc = " Used to disable a body. A disabled body does not move or collide."]
    pub isEnabled: bool,
    #[doc = " This allows this body to bypass rotational speed limits. Should only be used\n for circular objects, like wheels."]
    pub allowFastRotation: bool,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your body definition\n @ingroup body"]
    pub fn b2DefaultBodyDef() -> b2BodyDef;
}
#[doc = " This is used to filter collision on shapes. It affects shape-vs-shape collision\n and shape-versus-query collision (such as b2World_CastRay).\n @ingroup shape"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Filter {
    #[doc = " The collision category bits. Normally you would just set one bit. The category bits should\n represent your application object types. For example:\n @code{.cpp}\n enum MyCategories\n {\n    Static  = 0x00000001,\n    Dynamic = 0x00000002,\n    Debris  = 0x00000004,\n    Player  = 0x00000008,\n    // etc\n };\n @endcode"]
    pub categoryBits: u64,
    #[doc = " The collision mask bits. This states the categories that this\n shape would accept for collision.\n For example, you may want your player to only collide with static objects\n and other players.\n @code{.c}\n maskBits = Static | Player;\n @endcode"]
    pub maskBits: u64,
    #[doc = " Collision groups allow a certain group of objects to never collide (negative)\n or always collide (positive). A group index of zero has no effect. Non-zero group filtering\n always wins against the mask bits.\n For example, you may want ragdolls to collide with other ragdolls but you don't want\n ragdoll self-collision. In this case you would give each ragdoll a unique negative group index\n and apply that group index to all shapes on the ragdoll."]
    pub groupIndex: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your filter\n @ingroup shape"]
    pub fn b2DefaultFilter() -> b2Filter;
}
#[doc = " The query filter is used to filter collisions between queries and shapes. For example,\n you may want a ray-cast representing a projectile to hit players and the static environment\n but not debris.\n @ingroup shape"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2QueryFilter {
    #[doc = " The collision category bits of this query. Normally you would just set one bit."]
    pub categoryBits: u64,
    #[doc = " The collision mask bits. This states the shape categories that this\n query would accept for collision."]
    pub maskBits: u64,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your query filter\n @ingroup shape"]
    pub fn b2DefaultQueryFilter() -> b2QueryFilter;
}
#[doc = " A circle with an offset"]
pub const b2ShapeType_b2_circleShape: b2ShapeType = 0;
#[doc = " A capsule is an extruded circle"]
pub const b2ShapeType_b2_capsuleShape: b2ShapeType = 1;
#[doc = " A line segment"]
pub const b2ShapeType_b2_segmentShape: b2ShapeType = 2;
#[doc = " A convex polygon"]
pub const b2ShapeType_b2_polygonShape: b2ShapeType = 3;
#[doc = " A line segment owned by a chain shape"]
pub const b2ShapeType_b2_chainSegmentShape: b2ShapeType = 4;
#[doc = " The number of shape types"]
pub const b2ShapeType_b2_shapeTypeCount: b2ShapeType = 5;
#[doc = " Shape type\n @ingroup shape"]
pub type b2ShapeType = ::std::os::raw::c_int;
#[doc = " Surface materials allow chain shapes to have per segment surface properties.\n @ingroup shape"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SurfaceMaterial {
    #[doc = " The Coulomb (dry) friction coefficient, usually in the range [0,1]."]
    pub friction: f32,
    #[doc = " The coefficient of restitution (bounce) usually in the range [0,1].\n https://en.wikipedia.org/wiki/Coefficient_of_restitution"]
    pub restitution: f32,
    #[doc = " The rolling resistance usually in the range [0,1]."]
    pub rollingResistance: f32,
    #[doc = " The tangent speed for conveyor belts"]
    pub tangentSpeed: f32,
    #[doc = " User material identifier. This is passed with query results and to friction and restitution\n combining functions. It is not used internally."]
    pub userMaterialId: u64,
    #[doc = " Custom debug draw color."]
    pub customColor: u32,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your surface material\n @ingroup shape"]
    pub fn b2DefaultSurfaceMaterial() -> b2SurfaceMaterial;
}
#[doc = " Used to create a shape.\n This is a temporary object used to bundle shape creation parameters. You may use\n the same shape definition to create multiple shapes.\n Must be initialized using b2DefaultShapeDef().\n @ingroup shape"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ShapeDef {
    #[doc = " Use this to store application specific shape data."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " The surface material for this shape."]
    pub material: b2SurfaceMaterial,
    #[doc = " The density, usually in kg/m^2.\n This is not part of the surface material because this is for the interior, which may have\n other considerations, such as being hollow. For example a wood barrel may be hollow or full of water."]
    pub density: f32,
    #[doc = " Collision filtering data."]
    pub filter: b2Filter,
    #[doc = " Enable custom filtering. Only one of the two shapes needs to enable custom filtering. See b2WorldDef."]
    pub enableCustomFiltering: bool,
    #[doc = " A sensor shape generates overlap events but never generates a collision response.\n Sensors do not have continuous collision. Instead, use a ray or shape cast for those scenarios.\n Sensors still contribute to the body mass if they have non-zero density.\n @note Sensor events are disabled by default.\n @see enableSensorEvents"]
    pub isSensor: bool,
    #[doc = " Enable sensor events for this shape. This applies to sensors and non-sensors. False by default, even for sensors."]
    pub enableSensorEvents: bool,
    #[doc = " Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors. False by default."]
    pub enableContactEvents: bool,
    #[doc = " Enable hit events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors. False by default."]
    pub enableHitEvents: bool,
    #[doc = " Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive\n and must be carefully handled due to multithreading. Ignored for sensors."]
    pub enablePreSolveEvents: bool,
    #[doc = " When shapes are created they will scan the environment for collision the next time step. This can significantly slow down\n static body creation when there are many static shapes.\n This is flag is ignored for dynamic and kinematic shapes which always invoke contact creation."]
    pub invokeContactCreation: bool,
    #[doc = " Should the body update the mass properties when this shape is created. Default is true."]
    pub updateBodyMass: bool,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your shape definition\n @ingroup shape"]
    pub fn b2DefaultShapeDef() -> b2ShapeDef;
}
#[doc = " Used to create a chain of line segments. This is designed to eliminate ghost collisions with some limitations.\n - chains are one-sided\n - chains have no mass and should be used on static bodies\n - chains have a counter-clockwise winding order (normal points right of segment direction)\n - chains are either a loop or open\n - a chain must have at least 4 points\n - the distance between any two points must be greater than B2_LINEAR_SLOP\n - a chain shape should not self intersect (this is not validated)\n - an open chain shape has NO COLLISION on the first and final edge\n - you may overlap two open chains on their first three and/or last three points to get smooth collision\n - a chain shape creates multiple line segment shapes on the body\n https://en.wikipedia.org/wiki/Polygonal_chain\n Must be initialized using b2DefaultChainDef().\n @warning Do not use chain shapes unless you understand the limitations. This is an advanced feature.\n @ingroup shape"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ChainDef {
    #[doc = " Use this to store application specific shape data."]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " An array of at least 4 points. These are cloned and may be temporary."]
    pub points: *const b2Vec2,
    #[doc = " The point count, must be 4 or more."]
    pub count: ::std::os::raw::c_int,
    #[doc = " Surface materials for each segment. These are cloned."]
    pub materials: *const b2SurfaceMaterial,
    #[doc = " The material count. Must be 1 or count. This allows you to provide one\n material for all segments or a unique material per segment."]
    pub materialCount: ::std::os::raw::c_int,
    #[doc = " Contact filtering data."]
    pub filter: b2Filter,
    #[doc = " Indicates a closed chain formed by connecting the first and last points"]
    pub isLoop: bool,
    #[doc = " Enable sensors to detect this chain. False by default."]
    pub enableSensorEvents: bool,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your chain definition\n @ingroup shape"]
    pub fn b2DefaultChainDef() -> b2ChainDef;
}
#[doc = "! @cond\n Profiling data. Times are in milliseconds."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Profile {
    pub step: f32,
    pub pairs: f32,
    pub collide: f32,
    pub solve: f32,
    pub prepareStages: f32,
    pub solveConstraints: f32,
    pub prepareConstraints: f32,
    pub integrateVelocities: f32,
    pub warmStart: f32,
    pub solveImpulses: f32,
    pub integratePositions: f32,
    pub relaxImpulses: f32,
    pub applyRestitution: f32,
    pub storeImpulses: f32,
    pub splitIslands: f32,
    pub transforms: f32,
    pub sensorHits: f32,
    pub jointEvents: f32,
    pub hitEvents: f32,
    pub refit: f32,
    pub bullets: f32,
    pub sleepIslands: f32,
    pub sensors: f32,
}
#[doc = " Counters that give details of the simulation size."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2Counters {
    pub bodyCount: ::std::os::raw::c_int,
    pub shapeCount: ::std::os::raw::c_int,
    pub contactCount: ::std::os::raw::c_int,
    pub jointCount: ::std::os::raw::c_int,
    pub islandCount: ::std::os::raw::c_int,
    pub stackUsed: ::std::os::raw::c_int,
    pub staticTreeHeight: ::std::os::raw::c_int,
    pub treeHeight: ::std::os::raw::c_int,
    pub byteCount: ::std::os::raw::c_int,
    pub taskCount: ::std::os::raw::c_int,
    pub colorCounts: [::std::os::raw::c_int; 24usize],
}
pub const b2JointType_b2_distanceJoint: b2JointType = 0;
pub const b2JointType_b2_filterJoint: b2JointType = 1;
pub const b2JointType_b2_motorJoint: b2JointType = 2;
pub const b2JointType_b2_prismaticJoint: b2JointType = 3;
pub const b2JointType_b2_revoluteJoint: b2JointType = 4;
pub const b2JointType_b2_weldJoint: b2JointType = 5;
pub const b2JointType_b2_wheelJoint: b2JointType = 6;
#[doc = " Joint type enumeration\n\n This is useful because all joint types use b2JointId and sometimes you\n want to get the type of a joint.\n @ingroup joint"]
pub type b2JointType = ::std::os::raw::c_int;
#[doc = " Base joint definition used by all joint types.\n The local frames are measured from the body's origin rather than the center of mass because:\n 1. you might not know where the center of mass will be\n 2. if you add/remove shapes from a body and recompute the mass, the joints will be broken"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2JointDef {
    #[doc = " User data pointer"]
    pub userData: *mut ::std::os::raw::c_void,
    #[doc = " The first attached body"]
    pub bodyIdA: b2BodyId,
    #[doc = " The second attached body"]
    pub bodyIdB: b2BodyId,
    #[doc = " The first local joint frame"]
    pub localFrameA: b2Transform,
    #[doc = " The second local joint frame"]
    pub localFrameB: b2Transform,
    #[doc = " Force threshold for joint events"]
    pub forceThreshold: f32,
    #[doc = " Torque threshold for joint events"]
    pub torqueThreshold: f32,
    #[doc = " Constraint hertz (advanced feature)"]
    pub constraintHertz: f32,
    #[doc = " Constraint damping ratio (advanced feature)"]
    pub constraintDampingRatio: f32,
    #[doc = " Debug draw scale"]
    pub drawScale: f32,
    #[doc = " Set this flag to true if the attached bodies should collide"]
    pub collideConnected: bool,
}
#[doc = " Distance joint definition\n Connects a point on body A with a point on body B by a segment.\n Useful for ropes and springs.\n @ingroup distance_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2DistanceJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " The rest length of this joint. Clamped to a stable minimum value."]
    pub length: f32,
    #[doc = " Enable the distance constraint to behave like a spring. If false\n then the distance joint will be rigid, overriding the limit and motor."]
    pub enableSpring: bool,
    #[doc = " The lower spring force controls how much tension it can sustain"]
    pub lowerSpringForce: f32,
    #[doc = " The upper spring force controls how much compression it an sustain"]
    pub upperSpringForce: f32,
    #[doc = " The spring linear stiffness Hertz, cycles per second"]
    pub hertz: f32,
    #[doc = " The spring linear damping ratio, non-dimensional"]
    pub dampingRatio: f32,
    #[doc = " Enable/disable the joint limit"]
    pub enableLimit: bool,
    #[doc = " Minimum length. Clamped to a stable minimum value."]
    pub minLength: f32,
    #[doc = " Maximum length. Must be greater than or equal to the minimum length."]
    pub maxLength: f32,
    #[doc = " Enable/disable the joint motor"]
    pub enableMotor: bool,
    #[doc = " The maximum motor force, usually in newtons"]
    pub maxMotorForce: f32,
    #[doc = " The desired motor speed, usually in meters per second"]
    pub motorSpeed: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroup distance_joint"]
    pub fn b2DefaultDistanceJointDef() -> b2DistanceJointDef;
}
#[doc = " A motor joint is used to control the relative velocity and or transform between two bodies.\n With a velocity of zero this acts like top-down friction.\n @ingroup motor_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2MotorJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " The desired linear velocity"]
    pub linearVelocity: b2Vec2,
    #[doc = " The maximum motor force in newtons"]
    pub maxVelocityForce: f32,
    #[doc = " The desired angular velocity"]
    pub angularVelocity: f32,
    #[doc = " The maximum motor torque in newton-meters"]
    pub maxVelocityTorque: f32,
    #[doc = " Linear spring hertz for position control"]
    pub linearHertz: f32,
    #[doc = " Linear spring damping ratio"]
    pub linearDampingRatio: f32,
    #[doc = " Maximum spring force in newtons"]
    pub maxSpringForce: f32,
    #[doc = " Angular spring hertz for position control"]
    pub angularHertz: f32,
    #[doc = " Angular spring damping ratio"]
    pub angularDampingRatio: f32,
    #[doc = " Maximum spring torque in newton-meters"]
    pub maxSpringTorque: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroup motor_joint"]
    pub fn b2DefaultMotorJointDef() -> b2MotorJointDef;
}
#[doc = " A filter joint is used to disable collision between two specific bodies.\n\n @ingroup filter_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2FilterJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroup filter_joint"]
    pub fn b2DefaultFilterJointDef() -> b2FilterJointDef;
}
#[doc = " Prismatic joint definition\n Body B may slide along the x-axis in local frame A. Body B cannot rotate relative to body A.\n The joint translation is zero when the local frame origins coincide in world space.\n @ingroup prismatic_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2PrismaticJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " Enable a linear spring along the prismatic joint axis"]
    pub enableSpring: bool,
    #[doc = " The spring stiffness Hertz, cycles per second"]
    pub hertz: f32,
    #[doc = " The spring damping ratio, non-dimensional"]
    pub dampingRatio: f32,
    #[doc = " The target translation for the joint in meters. The spring-damper will drive\n to this translation."]
    pub targetTranslation: f32,
    #[doc = " Enable/disable the joint limit"]
    pub enableLimit: bool,
    #[doc = " The lower translation limit"]
    pub lowerTranslation: f32,
    #[doc = " The upper translation limit"]
    pub upperTranslation: f32,
    #[doc = " Enable/disable the joint motor"]
    pub enableMotor: bool,
    #[doc = " The maximum motor force, typically in newtons"]
    pub maxMotorForce: f32,
    #[doc = " The desired motor speed, typically in meters per second"]
    pub motorSpeed: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroupd prismatic_joint"]
    pub fn b2DefaultPrismaticJointDef() -> b2PrismaticJointDef;
}
#[doc = " Revolute joint definition\n A point on body B is fixed to a point on body A. Allows relative rotation.\n @ingroup revolute_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2RevoluteJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " The target angle for the joint in radians. The spring-damper will drive\n to this angle."]
    pub targetAngle: f32,
    #[doc = " Enable a rotational spring on the revolute hinge axis"]
    pub enableSpring: bool,
    #[doc = " The spring stiffness Hertz, cycles per second"]
    pub hertz: f32,
    #[doc = " The spring damping ratio, non-dimensional"]
    pub dampingRatio: f32,
    #[doc = " A flag to enable joint limits"]
    pub enableLimit: bool,
    #[doc = " The lower angle for the joint limit in radians. Minimum of -0.99*pi radians."]
    pub lowerAngle: f32,
    #[doc = " The upper angle for the joint limit in radians. Maximum of 0.99*pi radians."]
    pub upperAngle: f32,
    #[doc = " A flag to enable the joint motor"]
    pub enableMotor: bool,
    #[doc = " The maximum motor torque, typically in newton-meters"]
    pub maxMotorTorque: f32,
    #[doc = " The desired motor speed in radians per second"]
    pub motorSpeed: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition.\n @ingroup revolute_joint"]
    pub fn b2DefaultRevoluteJointDef() -> b2RevoluteJointDef;
}
#[doc = " Weld joint definition\n Connects two bodies together rigidly. This constraint provides springs to mimic\n soft-body simulation.\n @note The approximate solver in Box2D cannot hold many bodies together rigidly\n @ingroup weld_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2WeldJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " Linear stiffness expressed as Hertz (cycles per second). Use zero for maximum stiffness."]
    pub linearHertz: f32,
    #[doc = " Angular stiffness as Hertz (cycles per second). Use zero for maximum stiffness."]
    pub angularHertz: f32,
    #[doc = " Linear damping ratio, non-dimensional. Use 1 for critical damping."]
    pub linearDampingRatio: f32,
    #[doc = " Linear damping ratio, non-dimensional. Use 1 for critical damping."]
    pub angularDampingRatio: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroup weld_joint"]
    pub fn b2DefaultWeldJointDef() -> b2WeldJointDef;
}
#[doc = " Wheel joint definition\n Body B is a wheel that may rotate freely and slide along the local x-axis in frame A.\n The joint translation is zero when the local frame origins coincide in world space.\n @ingroup wheel_joint"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2WheelJointDef {
    #[doc = " Base joint definition"]
    pub base: b2JointDef,
    #[doc = " Enable a linear spring along the local axis"]
    pub enableSpring: bool,
    #[doc = " Spring stiffness in Hertz"]
    pub hertz: f32,
    #[doc = " Spring damping ratio, non-dimensional"]
    pub dampingRatio: f32,
    #[doc = " Enable/disable the joint linear limit"]
    pub enableLimit: bool,
    #[doc = " The lower translation limit"]
    pub lowerTranslation: f32,
    #[doc = " The upper translation limit"]
    pub upperTranslation: f32,
    #[doc = " Enable/disable the joint rotational motor"]
    pub enableMotor: bool,
    #[doc = " The maximum motor torque, typically in newton-meters"]
    pub maxMotorTorque: f32,
    #[doc = " The desired motor speed in radians per second"]
    pub motorSpeed: f32,
    #[doc = " Used internally to detect a valid definition. DO NOT SET."]
    pub internalValue: ::std::os::raw::c_int,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your joint definition\n @ingroup wheel_joint"]
    pub fn b2DefaultWheelJointDef() -> b2WheelJointDef;
}
#[doc = " The explosion definition is used to configure options for explosions. Explosions\n consider shape geometry when computing the impulse.\n @ingroup world"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ExplosionDef {
    #[doc = " Mask bits to filter shapes"]
    pub maskBits: u64,
    #[doc = " The center of the explosion in world space"]
    pub position: b2Vec2,
    #[doc = " The radius of the explosion"]
    pub radius: f32,
    #[doc = " The falloff distance beyond the radius. Impulse is reduced to zero at this distance."]
    pub falloff: f32,
    #[doc = " Impulse per unit length. This applies an impulse according to the shape perimeter that\n is facing the explosion. Explosions only apply to circles, capsules, and polygons. This\n may be negative for implosions."]
    pub impulsePerLength: f32,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your explosion definition\n @ingroup world"]
    pub fn b2DefaultExplosionDef() -> b2ExplosionDef;
}
#[doc = " A begin touch event is generated when a shape starts to overlap a sensor shape."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SensorBeginTouchEvent {
    #[doc = " The id of the sensor shape"]
    pub sensorShapeId: b2ShapeId,
    #[doc = " The id of the shape that began touching the sensor shape"]
    pub visitorShapeId: b2ShapeId,
}
#[doc = " An end touch event is generated when a shape stops overlapping a sensor shape.\n\tThese include things like setting the transform, destroying a body or shape, or changing\n\ta filter. You will also get an end event if the sensor or visitor are destroyed.\n\tTherefore you should always confirm the shape id is valid using b2Shape_IsValid."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SensorEndTouchEvent {
    #[doc = " The id of the sensor shape\n\t@warning this shape may have been destroyed\n\t@see b2Shape_IsValid"]
    pub sensorShapeId: b2ShapeId,
    #[doc = " The id of the shape that stopped touching the sensor shape\n\t@warning this shape may have been destroyed\n\t@see b2Shape_IsValid"]
    pub visitorShapeId: b2ShapeId,
}
#[doc = " Sensor events are buffered in the world and are available\n as begin/end overlap event arrays after the time step is complete.\n Note: these may become invalid if bodies and/or shapes are destroyed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2SensorEvents {
    #[doc = " Array of sensor begin touch events"]
    pub beginEvents: *mut b2SensorBeginTouchEvent,
    #[doc = " Array of sensor end touch events"]
    pub endEvents: *mut b2SensorEndTouchEvent,
    #[doc = " The number of begin touch events"]
    pub beginCount: ::std::os::raw::c_int,
    #[doc = " The number of end touch events"]
    pub endCount: ::std::os::raw::c_int,
}
#[doc = " A begin touch event is generated when two shapes begin touching."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactBeginTouchEvent {
    #[doc = " Id of the first shape"]
    pub shapeIdA: b2ShapeId,
    #[doc = " Id of the second shape"]
    pub shapeIdB: b2ShapeId,
    #[doc = " The transient contact id. This contact maybe destroyed automatically when the world is modified or simulated.\n Used b2Contact_IsValid before using this id."]
    pub contactId: b2ContactId,
}
#[doc = " An end touch event is generated when two shapes stop touching.\n\tYou will get an end event if you do anything that destroys contacts previous to the last\n\tworld step. These include things like setting the transform, destroying a body\n\tor shape, or changing a filter or body type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactEndTouchEvent {
    #[doc = " Id of the first shape\n\t@warning this shape may have been destroyed\n\t@see b2Shape_IsValid"]
    pub shapeIdA: b2ShapeId,
    #[doc = " Id of the second shape\n\t@warning this shape may have been destroyed\n\t@see b2Shape_IsValid"]
    pub shapeIdB: b2ShapeId,
    #[doc = " Id of the contact.\n\t@warning this contact may have been destroyed\n\t@see b2Contact_IsValid"]
    pub contactId: b2ContactId,
}
#[doc = " A hit touch event is generated when two shapes collide with a speed faster than the hit speed threshold.\n This may be reported for speculative contacts that have a confirmed impulse."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactHitEvent {
    #[doc = " Id of the first shape"]
    pub shapeIdA: b2ShapeId,
    #[doc = " Id of the second shape"]
    pub shapeIdB: b2ShapeId,
    #[doc = " Point where the shapes hit at the beginning of the time step.\n This is a mid-point between the two surfaces. It could be at speculative\n point where the two shapes were not touching at the beginning of the time step."]
    pub point: b2Vec2,
    #[doc = " Normal vector pointing from shape A to shape B"]
    pub normal: b2Vec2,
    #[doc = " The speed the shapes are approaching. Always positive. Typically in meters per second."]
    pub approachSpeed: f32,
}
#[doc = " Contact events are buffered in the Box2D world and are available\n as event arrays after the time step is complete.\n Note: these may become invalid if bodies and/or shapes are destroyed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactEvents {
    #[doc = " Array of begin touch events"]
    pub beginEvents: *mut b2ContactBeginTouchEvent,
    #[doc = " Array of end touch events"]
    pub endEvents: *mut b2ContactEndTouchEvent,
    #[doc = " Array of hit events"]
    pub hitEvents: *mut b2ContactHitEvent,
    #[doc = " Number of begin touch events"]
    pub beginCount: ::std::os::raw::c_int,
    #[doc = " Number of end touch events"]
    pub endCount: ::std::os::raw::c_int,
    #[doc = " Number of hit events"]
    pub hitCount: ::std::os::raw::c_int,
}
#[doc = " Body move events triggered when a body moves.\n Triggered when a body moves due to simulation. Not reported for bodies moved by the user.\n This also has a flag to indicate that the body went to sleep so the application can also\n sleep that actor/entity/object associated with the body.\n On the other hand if the flag does not indicate the body went to sleep then the application\n can treat the actor/entity/object associated with the body as awake.\n This is an efficient way for an application to update game object transforms rather than\n calling functions such as b2Body_GetTransform() because this data is delivered as a contiguous array\n and it is only populated with bodies that have moved.\n @note If sleeping is disabled all dynamic and kinematic bodies will trigger move events."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2BodyMoveEvent {
    pub userData: *mut ::std::os::raw::c_void,
    pub transform: b2Transform,
    pub bodyId: b2BodyId,
    pub fellAsleep: bool,
}
#[doc = " Body events are buffered in the Box2D world and are available\n as event arrays after the time step is complete.\n Note: this data becomes invalid if bodies are destroyed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2BodyEvents {
    #[doc = " Array of move events"]
    pub moveEvents: *mut b2BodyMoveEvent,
    #[doc = " Number of move events"]
    pub moveCount: ::std::os::raw::c_int,
}
#[doc = " Joint events report joints that are awake and have a force and/or torque exceeding the threshold\n The observed forces and torques are not returned for efficiency reasons."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2JointEvent {
    #[doc = " The joint id"]
    pub jointId: b2JointId,
    #[doc = " The user data from the joint for convenience"]
    pub userData: *mut ::std::os::raw::c_void,
}
#[doc = " Joint events are buffered in the world and are available\n as event arrays after the time step is complete.\n Note: this data becomes invalid if joints are destroyed"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2JointEvents {
    #[doc = " Array of events"]
    pub jointEvents: *mut b2JointEvent,
    #[doc = " Number of events"]
    pub count: ::std::os::raw::c_int,
}
#[doc = " The contact data for two shapes. By convention the manifold normal points\n from shape A to shape B.\n @see b2Shape_GetContactData() and b2Body_GetContactData()"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2ContactData {
    pub contactId: b2ContactId,
    pub shapeIdA: b2ShapeId,
    pub shapeIdB: b2ShapeId,
    pub manifold: b2Manifold,
}
#[doc = " Prototype for a contact filter callback.\n This is called when a contact pair is considered for collision. This allows you to\n perform custom logic to prevent collision between shapes. This is only called if\n one of the two shapes has custom filtering enabled.\n Notes:\n - this function must be thread-safe\n - this is only called if one of the two shapes has enabled custom filtering\n - this may be called for awake dynamic bodies and sensors\n Return false if you want to disable the collision\n @see b2ShapeDef\n @warning Do not attempt to modify the world inside this callback\n @ingroup world"]
pub type b2CustomFilterFcn = ::std::option::Option<
    unsafe extern "C" fn(
        shapeIdA: b2ShapeId,
        shapeIdB: b2ShapeId,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Prototype for a pre-solve callback.\n This is called after a contact is updated. This allows you to inspect a\n contact before it goes to the solver. If you are careful, you can modify the\n contact manifold (e.g. modify the normal).\n Notes:\n - this function must be thread-safe\n - this is only called if the shape has enabled pre-solve events\n - this is called only for awake dynamic bodies\n - this is not called for sensors\n - the supplied manifold has impulse values from the previous step\n Return false if you want to disable the contact this step\n @warning Do not attempt to modify the world inside this callback\n @ingroup world"]
pub type b2PreSolveFcn = ::std::option::Option<
    unsafe extern "C" fn(
        shapeIdA: b2ShapeId,
        shapeIdB: b2ShapeId,
        point: b2Vec2,
        normal: b2Vec2,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
#[doc = " Prototype callback for overlap queries.\n Called for each shape found in the query.\n @see b2World_OverlapABB\n @return false to terminate the query.\n @ingroup world"]
pub type b2OverlapResultFcn = ::std::option::Option<
    unsafe extern "C" fn(shapeId: b2ShapeId, context: *mut ::std::os::raw::c_void) -> bool,
>;
#[doc = " Prototype callback for ray and shape casts.\n Called for each shape found in the query. You control how the ray cast\n proceeds by returning a float:\n return -1: ignore this shape and continue\n return 0: terminate the ray cast\n return fraction: clip the ray to this point\n return 1: don't clip the ray and continue\n A cast with initial overlap will return a zero fraction and a zero normal.\n @param shapeId the shape hit by the ray\n @param point the point of initial intersection\n @param normal the normal vector at the point of intersection, zero for a shape cast with initial overlap\n @param fraction the fraction along the ray at the point of intersection, zero for a shape cast with initial overlap\n @param context the user context\n @return -1 to filter, 0 to terminate, fraction to clip the ray for closest hit, 1 to continue\n @see b2World_CastRay\n @ingroup world"]
pub type b2CastResultFcn = ::std::option::Option<
    unsafe extern "C" fn(
        shapeId: b2ShapeId,
        point: b2Vec2,
        normal: b2Vec2,
        fraction: f32,
        context: *mut ::std::os::raw::c_void,
    ) -> f32,
>;
pub type b2PlaneResultFcn = ::std::option::Option<
    unsafe extern "C" fn(
        shapeId: b2ShapeId,
        plane: *const b2PlaneResult,
        context: *mut ::std::os::raw::c_void,
    ) -> bool,
>;
pub const b2HexColor_b2_colorAliceBlue: b2HexColor = 15792383;
pub const b2HexColor_b2_colorAntiqueWhite: b2HexColor = 16444375;
pub const b2HexColor_b2_colorAqua: b2HexColor = 65535;
pub const b2HexColor_b2_colorAquamarine: b2HexColor = 8388564;
pub const b2HexColor_b2_colorAzure: b2HexColor = 15794175;
pub const b2HexColor_b2_colorBeige: b2HexColor = 16119260;
pub const b2HexColor_b2_colorBisque: b2HexColor = 16770244;
pub const b2HexColor_b2_colorBlack: b2HexColor = 0;
pub const b2HexColor_b2_colorBlanchedAlmond: b2HexColor = 16772045;
pub const b2HexColor_b2_colorBlue: b2HexColor = 255;
pub const b2HexColor_b2_colorBlueViolet: b2HexColor = 9055202;
pub const b2HexColor_b2_colorBrown: b2HexColor = 10824234;
pub const b2HexColor_b2_colorBurlywood: b2HexColor = 14596231;
pub const b2HexColor_b2_colorCadetBlue: b2HexColor = 6266528;
pub const b2HexColor_b2_colorChartreuse: b2HexColor = 8388352;
pub const b2HexColor_b2_colorChocolate: b2HexColor = 13789470;
pub const b2HexColor_b2_colorCoral: b2HexColor = 16744272;
pub const b2HexColor_b2_colorCornflowerBlue: b2HexColor = 6591981;
pub const b2HexColor_b2_colorCornsilk: b2HexColor = 16775388;
pub const b2HexColor_b2_colorCrimson: b2HexColor = 14423100;
pub const b2HexColor_b2_colorCyan: b2HexColor = 65535;
pub const b2HexColor_b2_colorDarkBlue: b2HexColor = 139;
pub const b2HexColor_b2_colorDarkCyan: b2HexColor = 35723;
pub const b2HexColor_b2_colorDarkGoldenRod: b2HexColor = 12092939;
pub const b2HexColor_b2_colorDarkGray: b2HexColor = 11119017;
pub const b2HexColor_b2_colorDarkGreen: b2HexColor = 25600;
pub const b2HexColor_b2_colorDarkKhaki: b2HexColor = 12433259;
pub const b2HexColor_b2_colorDarkMagenta: b2HexColor = 9109643;
pub const b2HexColor_b2_colorDarkOliveGreen: b2HexColor = 5597999;
pub const b2HexColor_b2_colorDarkOrange: b2HexColor = 16747520;
pub const b2HexColor_b2_colorDarkOrchid: b2HexColor = 10040012;
pub const b2HexColor_b2_colorDarkRed: b2HexColor = 9109504;
pub const b2HexColor_b2_colorDarkSalmon: b2HexColor = 15308410;
pub const b2HexColor_b2_colorDarkSeaGreen: b2HexColor = 9419919;
pub const b2HexColor_b2_colorDarkSlateBlue: b2HexColor = 4734347;
pub const b2HexColor_b2_colorDarkSlateGray: b2HexColor = 3100495;
pub const b2HexColor_b2_colorDarkTurquoise: b2HexColor = 52945;
pub const b2HexColor_b2_colorDarkViolet: b2HexColor = 9699539;
pub const b2HexColor_b2_colorDeepPink: b2HexColor = 16716947;
pub const b2HexColor_b2_colorDeepSkyBlue: b2HexColor = 49151;
pub const b2HexColor_b2_colorDimGray: b2HexColor = 6908265;
pub const b2HexColor_b2_colorDodgerBlue: b2HexColor = 2003199;
pub const b2HexColor_b2_colorFireBrick: b2HexColor = 11674146;
pub const b2HexColor_b2_colorFloralWhite: b2HexColor = 16775920;
pub const b2HexColor_b2_colorForestGreen: b2HexColor = 2263842;
pub const b2HexColor_b2_colorFuchsia: b2HexColor = 16711935;
pub const b2HexColor_b2_colorGainsboro: b2HexColor = 14474460;
pub const b2HexColor_b2_colorGhostWhite: b2HexColor = 16316671;
pub const b2HexColor_b2_colorGold: b2HexColor = 16766720;
pub const b2HexColor_b2_colorGoldenRod: b2HexColor = 14329120;
pub const b2HexColor_b2_colorGray: b2HexColor = 8421504;
pub const b2HexColor_b2_colorGreen: b2HexColor = 32768;
pub const b2HexColor_b2_colorGreenYellow: b2HexColor = 11403055;
pub const b2HexColor_b2_colorHoneyDew: b2HexColor = 15794160;
pub const b2HexColor_b2_colorHotPink: b2HexColor = 16738740;
pub const b2HexColor_b2_colorIndianRed: b2HexColor = 13458524;
pub const b2HexColor_b2_colorIndigo: b2HexColor = 4915330;
pub const b2HexColor_b2_colorIvory: b2HexColor = 16777200;
pub const b2HexColor_b2_colorKhaki: b2HexColor = 15787660;
pub const b2HexColor_b2_colorLavender: b2HexColor = 15132410;
pub const b2HexColor_b2_colorLavenderBlush: b2HexColor = 16773365;
pub const b2HexColor_b2_colorLawnGreen: b2HexColor = 8190976;
pub const b2HexColor_b2_colorLemonChiffon: b2HexColor = 16775885;
pub const b2HexColor_b2_colorLightBlue: b2HexColor = 11393254;
pub const b2HexColor_b2_colorLightCoral: b2HexColor = 15761536;
pub const b2HexColor_b2_colorLightCyan: b2HexColor = 14745599;
pub const b2HexColor_b2_colorLightGoldenRodYellow: b2HexColor = 16448210;
pub const b2HexColor_b2_colorLightGray: b2HexColor = 13882323;
pub const b2HexColor_b2_colorLightGreen: b2HexColor = 9498256;
pub const b2HexColor_b2_colorLightPink: b2HexColor = 16758465;
pub const b2HexColor_b2_colorLightSalmon: b2HexColor = 16752762;
pub const b2HexColor_b2_colorLightSeaGreen: b2HexColor = 2142890;
pub const b2HexColor_b2_colorLightSkyBlue: b2HexColor = 8900346;
pub const b2HexColor_b2_colorLightSlateGray: b2HexColor = 7833753;
pub const b2HexColor_b2_colorLightSteelBlue: b2HexColor = 11584734;
pub const b2HexColor_b2_colorLightYellow: b2HexColor = 16777184;
pub const b2HexColor_b2_colorLime: b2HexColor = 65280;
pub const b2HexColor_b2_colorLimeGreen: b2HexColor = 3329330;
pub const b2HexColor_b2_colorLinen: b2HexColor = 16445670;
pub const b2HexColor_b2_colorMagenta: b2HexColor = 16711935;
pub const b2HexColor_b2_colorMaroon: b2HexColor = 8388608;
pub const b2HexColor_b2_colorMediumAquaMarine: b2HexColor = 6737322;
pub const b2HexColor_b2_colorMediumBlue: b2HexColor = 205;
pub const b2HexColor_b2_colorMediumOrchid: b2HexColor = 12211667;
pub const b2HexColor_b2_colorMediumPurple: b2HexColor = 9662683;
pub const b2HexColor_b2_colorMediumSeaGreen: b2HexColor = 3978097;
pub const b2HexColor_b2_colorMediumSlateBlue: b2HexColor = 8087790;
pub const b2HexColor_b2_colorMediumSpringGreen: b2HexColor = 64154;
pub const b2HexColor_b2_colorMediumTurquoise: b2HexColor = 4772300;
pub const b2HexColor_b2_colorMediumVioletRed: b2HexColor = 13047173;
pub const b2HexColor_b2_colorMidnightBlue: b2HexColor = 1644912;
pub const b2HexColor_b2_colorMintCream: b2HexColor = 16121850;
pub const b2HexColor_b2_colorMistyRose: b2HexColor = 16770273;
pub const b2HexColor_b2_colorMoccasin: b2HexColor = 16770229;
pub const b2HexColor_b2_colorNavajoWhite: b2HexColor = 16768685;
pub const b2HexColor_b2_colorNavy: b2HexColor = 128;
pub const b2HexColor_b2_colorOldLace: b2HexColor = 16643558;
pub const b2HexColor_b2_colorOlive: b2HexColor = 8421376;
pub const b2HexColor_b2_colorOliveDrab: b2HexColor = 7048739;
pub const b2HexColor_b2_colorOrange: b2HexColor = 16753920;
pub const b2HexColor_b2_colorOrangeRed: b2HexColor = 16729344;
pub const b2HexColor_b2_colorOrchid: b2HexColor = 14315734;
pub const b2HexColor_b2_colorPaleGoldenRod: b2HexColor = 15657130;
pub const b2HexColor_b2_colorPaleGreen: b2HexColor = 10025880;
pub const b2HexColor_b2_colorPaleTurquoise: b2HexColor = 11529966;
pub const b2HexColor_b2_colorPaleVioletRed: b2HexColor = 14381203;
pub const b2HexColor_b2_colorPapayaWhip: b2HexColor = 16773077;
pub const b2HexColor_b2_colorPeachPuff: b2HexColor = 16767673;
pub const b2HexColor_b2_colorPeru: b2HexColor = 13468991;
pub const b2HexColor_b2_colorPink: b2HexColor = 16761035;
pub const b2HexColor_b2_colorPlum: b2HexColor = 14524637;
pub const b2HexColor_b2_colorPowderBlue: b2HexColor = 11591910;
pub const b2HexColor_b2_colorPurple: b2HexColor = 8388736;
pub const b2HexColor_b2_colorRebeccaPurple: b2HexColor = 6697881;
pub const b2HexColor_b2_colorRed: b2HexColor = 16711680;
pub const b2HexColor_b2_colorRosyBrown: b2HexColor = 12357519;
pub const b2HexColor_b2_colorRoyalBlue: b2HexColor = 4286945;
pub const b2HexColor_b2_colorSaddleBrown: b2HexColor = 9127187;
pub const b2HexColor_b2_colorSalmon: b2HexColor = 16416882;
pub const b2HexColor_b2_colorSandyBrown: b2HexColor = 16032864;
pub const b2HexColor_b2_colorSeaGreen: b2HexColor = 3050327;
pub const b2HexColor_b2_colorSeaShell: b2HexColor = 16774638;
pub const b2HexColor_b2_colorSienna: b2HexColor = 10506797;
pub const b2HexColor_b2_colorSilver: b2HexColor = 12632256;
pub const b2HexColor_b2_colorSkyBlue: b2HexColor = 8900331;
pub const b2HexColor_b2_colorSlateBlue: b2HexColor = 6970061;
pub const b2HexColor_b2_colorSlateGray: b2HexColor = 7372944;
pub const b2HexColor_b2_colorSnow: b2HexColor = 16775930;
pub const b2HexColor_b2_colorSpringGreen: b2HexColor = 65407;
pub const b2HexColor_b2_colorSteelBlue: b2HexColor = 4620980;
pub const b2HexColor_b2_colorTan: b2HexColor = 13808780;
pub const b2HexColor_b2_colorTeal: b2HexColor = 32896;
pub const b2HexColor_b2_colorThistle: b2HexColor = 14204888;
pub const b2HexColor_b2_colorTomato: b2HexColor = 16737095;
pub const b2HexColor_b2_colorTurquoise: b2HexColor = 4251856;
pub const b2HexColor_b2_colorViolet: b2HexColor = 15631086;
pub const b2HexColor_b2_colorWheat: b2HexColor = 16113331;
pub const b2HexColor_b2_colorWhite: b2HexColor = 16777215;
pub const b2HexColor_b2_colorWhiteSmoke: b2HexColor = 16119285;
pub const b2HexColor_b2_colorYellow: b2HexColor = 16776960;
pub const b2HexColor_b2_colorYellowGreen: b2HexColor = 10145074;
pub const b2HexColor_b2_colorBox2DRed: b2HexColor = 14430514;
pub const b2HexColor_b2_colorBox2DBlue: b2HexColor = 3190463;
pub const b2HexColor_b2_colorBox2DGreen: b2HexColor = 9226532;
pub const b2HexColor_b2_colorBox2DYellow: b2HexColor = 16772748;
#[doc = " These colors are used for debug draw and mostly match the named SVG colors.\n See https://www.rapidtables.com/web/color/index.html\n https://johndecember.com/html/spec/colorsvg.html\n https://upload.wikimedia.org/wikipedia/commons/2/2b/SVG_Recognized_color_keyword_names.svg"]
pub type b2HexColor = ::std::os::raw::c_int;
#[doc = " This struct holds callbacks you can implement to draw a Box2D world.\n This structure should be zero initialized.\n @ingroup world"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2DebugDraw {
    #[doc = " Draw a closed polygon provided in CCW order."]
    pub DrawPolygonFcn: ::std::option::Option<
        unsafe extern "C" fn(
            vertices: *const b2Vec2,
            vertexCount: ::std::os::raw::c_int,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a solid closed polygon provided in CCW order."]
    pub DrawSolidPolygonFcn: ::std::option::Option<
        unsafe extern "C" fn(
            transform: b2Transform,
            vertices: *const b2Vec2,
            vertexCount: ::std::os::raw::c_int,
            radius: f32,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a circle."]
    pub DrawCircleFcn: ::std::option::Option<
        unsafe extern "C" fn(
            center: b2Vec2,
            radius: f32,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a solid circle."]
    pub DrawSolidCircleFcn: ::std::option::Option<
        unsafe extern "C" fn(
            transform: b2Transform,
            radius: f32,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a solid capsule."]
    pub DrawSolidCapsuleFcn: ::std::option::Option<
        unsafe extern "C" fn(
            p1: b2Vec2,
            p2: b2Vec2,
            radius: f32,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a line segment."]
    pub DrawSegmentFcn: ::std::option::Option<
        unsafe extern "C" fn(
            p1: b2Vec2,
            p2: b2Vec2,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a transform. Choose your own length scale."]
    pub DrawTransformFcn: ::std::option::Option<
        unsafe extern "C" fn(transform: b2Transform, context: *mut ::std::os::raw::c_void),
    >,
    #[doc = " Draw a point."]
    pub DrawPointFcn: ::std::option::Option<
        unsafe extern "C" fn(
            p: b2Vec2,
            size: f32,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " Draw a string in world space"]
    pub DrawStringFcn: ::std::option::Option<
        unsafe extern "C" fn(
            p: b2Vec2,
            s: *const ::std::os::raw::c_char,
            color: b2HexColor,
            context: *mut ::std::os::raw::c_void,
        ),
    >,
    #[doc = " World bounds to use for debug draw"]
    pub drawingBounds: b2AABB,
    #[doc = " Scale to use when drawing forces"]
    pub forceScale: f32,
    #[doc = " Global scaling for joint drawing"]
    pub jointScale: f32,
    #[doc = " Option to draw shapes"]
    pub drawShapes: bool,
    #[doc = " Option to draw joints"]
    pub drawJoints: bool,
    #[doc = " Option to draw additional information for joints"]
    pub drawJointExtras: bool,
    #[doc = " Option to draw the bounding boxes for shapes"]
    pub drawBounds: bool,
    #[doc = " Option to draw the mass and center of mass of dynamic bodies"]
    pub drawMass: bool,
    #[doc = " Option to draw body names"]
    pub drawBodyNames: bool,
    #[doc = " Option to draw contact points"]
    pub drawContacts: bool,
    #[doc = " Option to visualize the graph coloring used for contacts and joints"]
    pub drawGraphColors: bool,
    #[doc = " Option to draw contact feature ids"]
    pub drawContactFeatures: bool,
    #[doc = " Option to draw contact normals"]
    pub drawContactNormals: bool,
    #[doc = " Option to draw contact normal forces"]
    pub drawContactForces: bool,
    #[doc = " Option to draw contact friction forces"]
    pub drawFrictionForces: bool,
    #[doc = " Option to draw islands as bounding boxes"]
    pub drawIslands: bool,
    #[doc = " User context that is passed as an argument to drawing callback functions"]
    pub context: *mut ::std::os::raw::c_void,
}
unsafe extern "C" {
    #[doc = " Use this to initialize your drawing interface. This allows you to implement a sub-set\n of the drawing functions."]
    pub fn b2DefaultDebugDraw() -> b2DebugDraw;
}
unsafe extern "C" {
    #[doc = " Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create\n up to 128 worlds. Each world is completely independent and may be simulated in parallel.\n @return the world id."]
    pub fn b2CreateWorld(def: *const b2WorldDef) -> b2WorldId;
}
unsafe extern "C" {
    #[doc = " Destroy a world"]
    pub fn b2DestroyWorld(worldId: b2WorldId);
}
unsafe extern "C" {
    #[doc = " World id validation. Provides validation for up to 64K allocations."]
    pub fn b2World_IsValid(id: b2WorldId) -> bool;
}
unsafe extern "C" {
    #[doc = " Simulate a world for one time step. This performs collision detection, integration, and constraint solution.\n @param worldId The world to simulate\n @param timeStep The amount of time to simulate, this should be a fixed number. Usually 1/60.\n @param subStepCount The number of sub-steps, increasing the sub-step count can increase accuracy. Usually 4."]
    pub fn b2World_Step(worldId: b2WorldId, timeStep: f32, subStepCount: ::std::os::raw::c_int);
}
unsafe extern "C" {
    #[doc = " Call this to draw shapes and other debug draw data"]
    pub fn b2World_Draw(worldId: b2WorldId, draw: *mut b2DebugDraw);
}
unsafe extern "C" {
    #[doc = " Get the body events for the current time step. The event data is transient. Do not store a reference to this data."]
    pub fn b2World_GetBodyEvents(worldId: b2WorldId) -> b2BodyEvents;
}
unsafe extern "C" {
    #[doc = " Get sensor events for the current time step. The event data is transient. Do not store a reference to this data."]
    pub fn b2World_GetSensorEvents(worldId: b2WorldId) -> b2SensorEvents;
}
unsafe extern "C" {
    #[doc = " Get contact events for this current time step. The event data is transient. Do not store a reference to this data."]
    pub fn b2World_GetContactEvents(worldId: b2WorldId) -> b2ContactEvents;
}
unsafe extern "C" {
    #[doc = " Get the joint events for the current time step. The event data is transient. Do not store a reference to this data."]
    pub fn b2World_GetJointEvents(worldId: b2WorldId) -> b2JointEvents;
}
unsafe extern "C" {
    #[doc = " Overlap test for all shapes that *potentially* overlap the provided AABB"]
    pub fn b2World_OverlapAABB(
        worldId: b2WorldId,
        aabb: b2AABB,
        filter: b2QueryFilter,
        fcn: b2OverlapResultFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Overlap test for all shapes that overlap the provided shape proxy."]
    pub fn b2World_OverlapShape(
        worldId: b2WorldId,
        proxy: *const b2ShapeProxy,
        filter: b2QueryFilter,
        fcn: b2OverlapResultFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Cast a ray into the world to collect shapes in the path of the ray.\n Your callback function controls whether you get the closest point, any point, or n-points.\n @note The callback function may receive shapes in any order\n @param worldId The world to cast the ray against\n @param origin The start point of the ray\n @param translation The translation of the ray from the start point to the end point\n @param filter Contains bit flags to filter unwanted shapes from the results\n @param fcn A user implemented callback function\n @param context A user context that is passed along to the callback function\n\t@return traversal performance counters"]
    pub fn b2World_CastRay(
        worldId: b2WorldId,
        origin: b2Vec2,
        translation: b2Vec2,
        filter: b2QueryFilter,
        fcn: b2CastResultFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Cast a ray into the world to collect the closest hit. This is a convenience function. Ignores initial overlap.\n This is less general than b2World_CastRay() and does not allow for custom filtering."]
    pub fn b2World_CastRayClosest(
        worldId: b2WorldId,
        origin: b2Vec2,
        translation: b2Vec2,
        filter: b2QueryFilter,
    ) -> b2RayResult;
}
unsafe extern "C" {
    #[doc = " Cast a shape through the world. Similar to a cast ray except that a shape is cast instead of a point.\n\t@see b2World_CastRay"]
    pub fn b2World_CastShape(
        worldId: b2WorldId,
        proxy: *const b2ShapeProxy,
        translation: b2Vec2,
        filter: b2QueryFilter,
        fcn: b2CastResultFcn,
        context: *mut ::std::os::raw::c_void,
    ) -> b2TreeStats;
}
unsafe extern "C" {
    #[doc = " Cast a capsule mover through the world. This is a special shape cast that handles sliding along other shapes while reducing\n clipping."]
    pub fn b2World_CastMover(
        worldId: b2WorldId,
        mover: *const b2Capsule,
        translation: b2Vec2,
        filter: b2QueryFilter,
    ) -> f32;
}
unsafe extern "C" {
    #[doc = " Collide a capsule mover with the world, gathering collision planes that can be fed to b2SolvePlanes. Useful for\n kinematic character movement."]
    pub fn b2World_CollideMover(
        worldId: b2WorldId,
        mover: *const b2Capsule,
        filter: b2QueryFilter,
        fcn: b2PlaneResultFcn,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Enable/disable sleep. If your application does not need sleeping, you can gain some performance\n by disabling sleep completely at the world level.\n @see b2WorldDef"]
    pub fn b2World_EnableSleeping(worldId: b2WorldId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Is body sleeping enabled?"]
    pub fn b2World_IsSleepingEnabled(worldId: b2WorldId) -> bool;
}
unsafe extern "C" {
    #[doc = " Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous\n collision enabled to prevent fast moving objects from going through static objects. The performance gain from\n disabling continuous collision is minor.\n @see b2WorldDef"]
    pub fn b2World_EnableContinuous(worldId: b2WorldId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Is continuous collision enabled?"]
    pub fn b2World_IsContinuousEnabled(worldId: b2WorldId) -> bool;
}
unsafe extern "C" {
    #[doc = " Adjust the restitution threshold. It is recommended not to make this value very small\n because it will prevent bodies from sleeping. Usually in meters per second.\n @see b2WorldDef"]
    pub fn b2World_SetRestitutionThreshold(worldId: b2WorldId, value: f32);
}
unsafe extern "C" {
    #[doc = " Get the the restitution speed threshold. Usually in meters per second."]
    pub fn b2World_GetRestitutionThreshold(worldId: b2WorldId) -> f32;
}
unsafe extern "C" {
    #[doc = " Adjust the hit event threshold. This controls the collision speed needed to generate a b2ContactHitEvent.\n Usually in meters per second.\n @see b2WorldDef::hitEventThreshold"]
    pub fn b2World_SetHitEventThreshold(worldId: b2WorldId, value: f32);
}
unsafe extern "C" {
    #[doc = " Get the the hit event speed threshold. Usually in meters per second."]
    pub fn b2World_GetHitEventThreshold(worldId: b2WorldId) -> f32;
}
unsafe extern "C" {
    #[doc = " Register the custom filter callback. This is optional."]
    pub fn b2World_SetCustomFilterCallback(
        worldId: b2WorldId,
        fcn: b2CustomFilterFcn,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Register the pre-solve callback. This is optional."]
    pub fn b2World_SetPreSolveCallback(
        worldId: b2WorldId,
        fcn: b2PreSolveFcn,
        context: *mut ::std::os::raw::c_void,
    );
}
unsafe extern "C" {
    #[doc = " Set the gravity vector for the entire world. Box2D has no concept of an up direction and this\n is left as a decision for the application. Usually in m/s^2.\n @see b2WorldDef"]
    pub fn b2World_SetGravity(worldId: b2WorldId, gravity: b2Vec2);
}
unsafe extern "C" {
    #[doc = " Get the gravity vector"]
    pub fn b2World_GetGravity(worldId: b2WorldId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Apply a radial explosion\n @param worldId The world id\n @param explosionDef The explosion definition"]
    pub fn b2World_Explode(worldId: b2WorldId, explosionDef: *const b2ExplosionDef);
}
unsafe extern "C" {
    #[doc = " Adjust contact tuning parameters\n @param worldId The world id\n @param hertz The contact stiffness (cycles per second)\n @param dampingRatio The contact bounciness with 1 being critical damping (non-dimensional)\n @param pushSpeed The maximum contact constraint push out speed (meters per second)\n @note Advanced feature"]
    pub fn b2World_SetContactTuning(
        worldId: b2WorldId,
        hertz: f32,
        dampingRatio: f32,
        pushSpeed: f32,
    );
}
unsafe extern "C" {
    #[doc = " Set the maximum linear speed. Usually in m/s."]
    pub fn b2World_SetMaximumLinearSpeed(worldId: b2WorldId, maximumLinearSpeed: f32);
}
unsafe extern "C" {
    #[doc = " Get the maximum linear speed. Usually in m/s."]
    pub fn b2World_GetMaximumLinearSpeed(worldId: b2WorldId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable constraint warm starting. Advanced feature for testing. Disabling\n warm starting greatly reduces stability and provides no performance gain."]
    pub fn b2World_EnableWarmStarting(worldId: b2WorldId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Is constraint warm starting enabled?"]
    pub fn b2World_IsWarmStartingEnabled(worldId: b2WorldId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the number of awake bodies."]
    pub fn b2World_GetAwakeBodyCount(worldId: b2WorldId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current world performance profile"]
    pub fn b2World_GetProfile(worldId: b2WorldId) -> b2Profile;
}
unsafe extern "C" {
    #[doc = " Get world counters and sizes"]
    pub fn b2World_GetCounters(worldId: b2WorldId) -> b2Counters;
}
unsafe extern "C" {
    #[doc = " Set the user data pointer."]
    pub fn b2World_SetUserData(worldId: b2WorldId, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the user data pointer."]
    pub fn b2World_GetUserData(worldId: b2WorldId) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Set the friction callback. Passing NULL resets to default."]
    pub fn b2World_SetFrictionCallback(worldId: b2WorldId, callback: b2FrictionCallback);
}
unsafe extern "C" {
    #[doc = " Set the restitution callback. Passing NULL resets to default."]
    pub fn b2World_SetRestitutionCallback(worldId: b2WorldId, callback: b2RestitutionCallback);
}
unsafe extern "C" {
    #[doc = " Dump memory stats to box2d_memory.txt"]
    pub fn b2World_DumpMemoryStats(worldId: b2WorldId);
}
unsafe extern "C" {
    #[doc = " This is for internal testing"]
    pub fn b2World_RebuildStaticTree(worldId: b2WorldId);
}
unsafe extern "C" {
    #[doc = " This is for internal testing"]
    pub fn b2World_EnableSpeculative(worldId: b2WorldId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition\n on the stack and pass it as a pointer.\n @code{.c}\n b2BodyDef bodyDef = b2DefaultBodyDef();\n b2BodyId myBodyId = b2CreateBody(myWorldId, &bodyDef);\n @endcode\n @warning This function is locked during callbacks."]
    pub fn b2CreateBody(worldId: b2WorldId, def: *const b2BodyDef) -> b2BodyId;
}
unsafe extern "C" {
    #[doc = " Destroy a rigid body given an id. This destroys all shapes and joints attached to the body.\n Do not keep references to the associated shapes and joints."]
    pub fn b2DestroyBody(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Body identifier validation. A valid body exists in a world and is non-null.\n This can be used to detect orphaned ids. Provides validation for up to 64K allocations."]
    pub fn b2Body_IsValid(id: b2BodyId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the body type: static, kinematic, or dynamic"]
    pub fn b2Body_GetType(bodyId: b2BodyId) -> b2BodyType;
}
unsafe extern "C" {
    #[doc = " Change the body type. This is an expensive operation. This automatically updates the mass\n properties regardless of the automatic mass setting."]
    pub fn b2Body_SetType(bodyId: b2BodyId, type_: b2BodyType);
}
unsafe extern "C" {
    #[doc = " Set the body name. Up to 31 characters excluding 0 termination."]
    pub fn b2Body_SetName(bodyId: b2BodyId, name: *const ::std::os::raw::c_char);
}
unsafe extern "C" {
    #[doc = " Get the body name."]
    pub fn b2Body_GetName(bodyId: b2BodyId) -> *const ::std::os::raw::c_char;
}
unsafe extern "C" {
    #[doc = " Set the user data for a body"]
    pub fn b2Body_SetUserData(bodyId: b2BodyId, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the user data stored in a body"]
    pub fn b2Body_GetUserData(bodyId: b2BodyId) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Get the world position of a body. This is the location of the body origin."]
    pub fn b2Body_GetPosition(bodyId: b2BodyId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the world rotation of a body as a cosine/sine pair (complex number)"]
    pub fn b2Body_GetRotation(bodyId: b2BodyId) -> b2Rot;
}
unsafe extern "C" {
    #[doc = " Get the world transform of a body."]
    pub fn b2Body_GetTransform(bodyId: b2BodyId) -> b2Transform;
}
unsafe extern "C" {
    #[doc = " Set the world transform of a body. This acts as a teleport and is fairly expensive.\n @note Generally you should create a body with then intended transform.\n @see b2BodyDef::position and b2BodyDef::rotation"]
    pub fn b2Body_SetTransform(bodyId: b2BodyId, position: b2Vec2, rotation: b2Rot);
}
unsafe extern "C" {
    #[doc = " Get a local point on a body given a world point"]
    pub fn b2Body_GetLocalPoint(bodyId: b2BodyId, worldPoint: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get a world point on a body given a local point"]
    pub fn b2Body_GetWorldPoint(bodyId: b2BodyId, localPoint: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get a local vector on a body given a world vector"]
    pub fn b2Body_GetLocalVector(bodyId: b2BodyId, worldVector: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get a world vector on a body given a local vector"]
    pub fn b2Body_GetWorldVector(bodyId: b2BodyId, localVector: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the linear velocity of a body's center of mass. Usually in meters per second."]
    pub fn b2Body_GetLinearVelocity(bodyId: b2BodyId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the angular velocity of a body in radians per second"]
    pub fn b2Body_GetAngularVelocity(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the linear velocity of a body. Usually in meters per second."]
    pub fn b2Body_SetLinearVelocity(bodyId: b2BodyId, linearVelocity: b2Vec2);
}
unsafe extern "C" {
    #[doc = " Set the angular velocity of a body in radians per second"]
    pub fn b2Body_SetAngularVelocity(bodyId: b2BodyId, angularVelocity: f32);
}
unsafe extern "C" {
    #[doc = " Set the velocity to reach the given transform after a given time step.\n The result will be close but maybe not exact. This is meant for kinematic bodies.\n The target is not applied if the velocity would be below the sleep threshold.\n This will automatically wake the body if asleep."]
    pub fn b2Body_SetTargetTransform(bodyId: b2BodyId, target: b2Transform, timeStep: f32);
}
unsafe extern "C" {
    #[doc = " Get the linear velocity of a local point attached to a body. Usually in meters per second."]
    pub fn b2Body_GetLocalPointVelocity(bodyId: b2BodyId, localPoint: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the linear velocity of a world point attached to a body. Usually in meters per second."]
    pub fn b2Body_GetWorldPointVelocity(bodyId: b2BodyId, worldPoint: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Apply a force at a world point. If the force is not applied at the center of mass,\n it will generate a torque and affect the angular velocity. This optionally wakes up the body.\n The force is ignored if the body is not awake.\n @param bodyId The body id\n @param force The world force vector, usually in newtons (N)\n @param point The world position of the point of application\n @param wake Option to wake up the body"]
    pub fn b2Body_ApplyForce(bodyId: b2BodyId, force: b2Vec2, point: b2Vec2, wake: bool);
}
unsafe extern "C" {
    #[doc = " Apply a force to the center of mass. This optionally wakes up the body.\n The force is ignored if the body is not awake.\n @param bodyId The body id\n @param force the world force vector, usually in newtons (N).\n @param wake also wake up the body"]
    pub fn b2Body_ApplyForceToCenter(bodyId: b2BodyId, force: b2Vec2, wake: bool);
}
unsafe extern "C" {
    #[doc = " Apply a torque. This affects the angular velocity without affecting the linear velocity.\n This optionally wakes the body. The torque is ignored if the body is not awake.\n @param bodyId The body id\n @param torque about the z-axis (out of the screen), usually in N*m.\n @param wake also wake up the body"]
    pub fn b2Body_ApplyTorque(bodyId: b2BodyId, torque: f32, wake: bool);
}
unsafe extern "C" {
    #[doc = " Clear the force and torque on this body. Forces and torques are automatically cleared after each world\n step. So this only needs to be called if the application wants to remove the effect of previous\n calls to apply forces and torques before the world step is called.\n @param bodyId The body id"]
    pub fn b2Body_ClearForces(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Apply an impulse at a point. This immediately modifies the velocity.\n It also modifies the angular velocity if the point of application\n is not at the center of mass. This optionally wakes the body.\n The impulse is ignored if the body is not awake.\n @param bodyId The body id\n @param impulse the world impulse vector, usually in N*s or kg*m/s.\n @param point the world position of the point of application.\n @param wake also wake up the body\n @warning This should be used for one-shot impulses. If you need a steady force,\n use a force instead, which will work better with the sub-stepping solver."]
    pub fn b2Body_ApplyLinearImpulse(bodyId: b2BodyId, impulse: b2Vec2, point: b2Vec2, wake: bool);
}
unsafe extern "C" {
    #[doc = " Apply an impulse to the center of mass. This immediately modifies the velocity.\n The impulse is ignored if the body is not awake. This optionally wakes the body.\n @param bodyId The body id\n @param impulse the world impulse vector, usually in N*s or kg*m/s.\n @param wake also wake up the body\n @warning This should be used for one-shot impulses. If you need a steady force,\n use a force instead, which will work better with the sub-stepping solver."]
    pub fn b2Body_ApplyLinearImpulseToCenter(bodyId: b2BodyId, impulse: b2Vec2, wake: bool);
}
unsafe extern "C" {
    #[doc = " Apply an angular impulse. The impulse is ignored if the body is not awake.\n This optionally wakes the body.\n @param bodyId The body id\n @param impulse the angular impulse, usually in units of kg*m*m/s\n @param wake also wake up the body\n @warning This should be used for one-shot impulses. If you need a steady torque,\n use a torque instead, which will work better with the sub-stepping solver."]
    pub fn b2Body_ApplyAngularImpulse(bodyId: b2BodyId, impulse: f32, wake: bool);
}
unsafe extern "C" {
    #[doc = " Get the mass of the body, usually in kilograms"]
    pub fn b2Body_GetMass(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the rotational inertia of the body, usually in kg*m^2"]
    pub fn b2Body_GetRotationalInertia(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the center of mass position of the body in local space"]
    pub fn b2Body_GetLocalCenterOfMass(bodyId: b2BodyId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the center of mass position of the body in world space"]
    pub fn b2Body_GetWorldCenterOfMass(bodyId: b2BodyId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Override the body's mass properties. Normally this is computed automatically using the\n shape geometry and density. This information is lost if a shape is added or removed or if the\n body type changes."]
    pub fn b2Body_SetMassData(bodyId: b2BodyId, massData: b2MassData);
}
unsafe extern "C" {
    #[doc = " Get the mass data for a body"]
    pub fn b2Body_GetMassData(bodyId: b2BodyId) -> b2MassData;
}
unsafe extern "C" {
    #[doc = " This update the mass properties to the sum of the mass properties of the shapes.\n This normally does not need to be called unless you called SetMassData to override\n the mass and you later want to reset the mass.\n You may also use this when automatic mass computation has been disabled.\n You should call this regardless of body type.\n Note that sensor shapes may have mass."]
    pub fn b2Body_ApplyMassFromShapes(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Adjust the linear damping. Normally this is set in b2BodyDef before creation."]
    pub fn b2Body_SetLinearDamping(bodyId: b2BodyId, linearDamping: f32);
}
unsafe extern "C" {
    #[doc = " Get the current linear damping."]
    pub fn b2Body_GetLinearDamping(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Adjust the angular damping. Normally this is set in b2BodyDef before creation."]
    pub fn b2Body_SetAngularDamping(bodyId: b2BodyId, angularDamping: f32);
}
unsafe extern "C" {
    #[doc = " Get the current angular damping."]
    pub fn b2Body_GetAngularDamping(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Adjust the gravity scale. Normally this is set in b2BodyDef before creation.\n @see b2BodyDef::gravityScale"]
    pub fn b2Body_SetGravityScale(bodyId: b2BodyId, gravityScale: f32);
}
unsafe extern "C" {
    #[doc = " Get the current gravity scale"]
    pub fn b2Body_GetGravityScale(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " @return true if this body is awake"]
    pub fn b2Body_IsAwake(bodyId: b2BodyId) -> bool;
}
unsafe extern "C" {
    #[doc = " Wake a body from sleep. This wakes the entire island the body is touching.\n @warning Putting a body to sleep will put the entire island of bodies touching this body to sleep,\n which can be expensive and possibly unintuitive."]
    pub fn b2Body_SetAwake(bodyId: b2BodyId, awake: bool);
}
unsafe extern "C" {
    #[doc = " Wake bodies touching this body. Works for static bodies."]
    pub fn b2Body_WakeTouching(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Enable or disable sleeping for this body. If sleeping is disabled the body will wake."]
    pub fn b2Body_EnableSleep(bodyId: b2BodyId, enableSleep: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if sleeping is enabled for this body"]
    pub fn b2Body_IsSleepEnabled(bodyId: b2BodyId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the sleep threshold, usually in meters per second"]
    pub fn b2Body_SetSleepThreshold(bodyId: b2BodyId, sleepThreshold: f32);
}
unsafe extern "C" {
    #[doc = " Get the sleep threshold, usually in meters per second."]
    pub fn b2Body_GetSleepThreshold(bodyId: b2BodyId) -> f32;
}
unsafe extern "C" {
    #[doc = " Returns true if this body is enabled"]
    pub fn b2Body_IsEnabled(bodyId: b2BodyId) -> bool;
}
unsafe extern "C" {
    #[doc = " Disable a body by removing it completely from the simulation. This is expensive."]
    pub fn b2Body_Disable(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Enable a body by adding it to the simulation. This is expensive."]
    pub fn b2Body_Enable(bodyId: b2BodyId);
}
unsafe extern "C" {
    #[doc = " Set the motion locks on this body."]
    pub fn b2Body_SetMotionLocks(bodyId: b2BodyId, locks: b2MotionLocks);
}
unsafe extern "C" {
    #[doc = " Get the motion locks for this body."]
    pub fn b2Body_GetMotionLocks(bodyId: b2BodyId) -> b2MotionLocks;
}
unsafe extern "C" {
    #[doc = " Set this body to be a bullet. A bullet does continuous collision detection\n against dynamic bodies (but not other bullets)."]
    pub fn b2Body_SetBullet(bodyId: b2BodyId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Is this body a bullet?"]
    pub fn b2Body_IsBullet(bodyId: b2BodyId) -> bool;
}
unsafe extern "C" {
    #[doc = " Enable/disable contact events on all shapes.\n @see b2ShapeDef::enableContactEvents\n @warning changing this at runtime may cause mismatched begin/end touch events"]
    pub fn b2Body_EnableContactEvents(bodyId: b2BodyId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Enable/disable hit events on all shapes\n @see b2ShapeDef::enableHitEvents"]
    pub fn b2Body_EnableHitEvents(bodyId: b2BodyId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Get the world that owns this body"]
    pub fn b2Body_GetWorld(bodyId: b2BodyId) -> b2WorldId;
}
unsafe extern "C" {
    #[doc = " Get the number of shapes on this body"]
    pub fn b2Body_GetShapeCount(bodyId: b2BodyId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the shape ids for all shapes on this body, up to the provided capacity.\n @returns the number of shape ids stored in the user array"]
    pub fn b2Body_GetShapes(
        bodyId: b2BodyId,
        shapeArray: *mut b2ShapeId,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of joints on this body"]
    pub fn b2Body_GetJointCount(bodyId: b2BodyId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the joint ids for all joints on this body, up to the provided capacity\n @returns the number of joint ids stored in the user array"]
    pub fn b2Body_GetJoints(
        bodyId: b2BodyId,
        jointArray: *mut b2JointId,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the maximum capacity required for retrieving all the touching contacts on a body"]
    pub fn b2Body_GetContactCapacity(bodyId: b2BodyId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the touching contact data for a body.\n @note Box2D uses speculative collision so some contact points may be separated.\n @returns the number of elements filled in the provided array\n @warning do not ignore the return value, it specifies the valid number of elements"]
    pub fn b2Body_GetContactData(
        bodyId: b2BodyId,
        contactData: *mut b2ContactData,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current world AABB that contains all the attached shapes. Note that this may not encompass the body origin.\n If there are no shapes attached then the returned AABB is empty and centered on the body origin."]
    pub fn b2Body_ComputeAABB(bodyId: b2BodyId) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.\n Contacts are not created until the next time step.\n @return the shape id for accessing the shape"]
    pub fn b2CreateCircleShape(
        bodyId: b2BodyId,
        def: *const b2ShapeDef,
        circle: *const b2Circle,
    ) -> b2ShapeId;
}
unsafe extern "C" {
    #[doc = " Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.\n Contacts are not created until the next time step.\n @return the shape id for accessing the shape"]
    pub fn b2CreateSegmentShape(
        bodyId: b2BodyId,
        def: *const b2ShapeDef,
        segment: *const b2Segment,
    ) -> b2ShapeId;
}
unsafe extern "C" {
    #[doc = " Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.\n Contacts are not created until the next time step.\n @return the shape id for accessing the shape"]
    pub fn b2CreateCapsuleShape(
        bodyId: b2BodyId,
        def: *const b2ShapeDef,
        capsule: *const b2Capsule,
    ) -> b2ShapeId;
}
unsafe extern "C" {
    #[doc = " Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.\n Contacts are not created until the next time step.\n @return the shape id for accessing the shape"]
    pub fn b2CreatePolygonShape(
        bodyId: b2BodyId,
        def: *const b2ShapeDef,
        polygon: *const b2Polygon,
    ) -> b2ShapeId;
}
unsafe extern "C" {
    #[doc = " Destroy a shape. You may defer the body mass update which can improve performance if several shapes on a\n\tbody are destroyed at once.\n\t@see b2Body_ApplyMassFromShapes"]
    pub fn b2DestroyShape(shapeId: b2ShapeId, updateBodyMass: bool);
}
unsafe extern "C" {
    #[doc = " Shape identifier validation. Provides validation for up to 64K allocations."]
    pub fn b2Shape_IsValid(id: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the type of a shape"]
    pub fn b2Shape_GetType(shapeId: b2ShapeId) -> b2ShapeType;
}
unsafe extern "C" {
    #[doc = " Get the id of the body that a shape is attached to"]
    pub fn b2Shape_GetBody(shapeId: b2ShapeId) -> b2BodyId;
}
unsafe extern "C" {
    #[doc = " Get the world that owns this shape"]
    pub fn b2Shape_GetWorld(shapeId: b2ShapeId) -> b2WorldId;
}
unsafe extern "C" {
    #[doc = " Returns true if the shape is a sensor. It is not possible to change a shape\n from sensor to solid dynamically because this breaks the contract for\n sensor events."]
    pub fn b2Shape_IsSensor(shapeId: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the user data for a shape"]
    pub fn b2Shape_SetUserData(shapeId: b2ShapeId, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the user data for a shape. This is useful when you get a shape id\n from an event or query."]
    pub fn b2Shape_GetUserData(shapeId: b2ShapeId) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Set the mass density of a shape, usually in kg/m^2.\n This will optionally update the mass properties on the parent body.\n @see b2ShapeDef::density, b2Body_ApplyMassFromShapes"]
    pub fn b2Shape_SetDensity(shapeId: b2ShapeId, density: f32, updateBodyMass: bool);
}
unsafe extern "C" {
    #[doc = " Get the density of a shape, usually in kg/m^2"]
    pub fn b2Shape_GetDensity(shapeId: b2ShapeId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the friction on a shape"]
    pub fn b2Shape_SetFriction(shapeId: b2ShapeId, friction: f32);
}
unsafe extern "C" {
    #[doc = " Get the friction of a shape"]
    pub fn b2Shape_GetFriction(shapeId: b2ShapeId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the shape restitution (bounciness)"]
    pub fn b2Shape_SetRestitution(shapeId: b2ShapeId, restitution: f32);
}
unsafe extern "C" {
    #[doc = " Get the shape restitution"]
    pub fn b2Shape_GetRestitution(shapeId: b2ShapeId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the user material identifier"]
    pub fn b2Shape_SetUserMaterial(shapeId: b2ShapeId, material: u64);
}
unsafe extern "C" {
    #[doc = " Get the user material identifier"]
    pub fn b2Shape_GetUserMaterial(shapeId: b2ShapeId) -> u64;
}
unsafe extern "C" {
    #[doc = " Set the shape surface material"]
    pub fn b2Shape_SetSurfaceMaterial(
        shapeId: b2ShapeId,
        surfaceMaterial: *const b2SurfaceMaterial,
    );
}
unsafe extern "C" {
    #[doc = " Get the shape surface material"]
    pub fn b2Shape_GetSurfaceMaterial(shapeId: b2ShapeId) -> b2SurfaceMaterial;
}
unsafe extern "C" {
    #[doc = " Get the shape filter"]
    pub fn b2Shape_GetFilter(shapeId: b2ShapeId) -> b2Filter;
}
unsafe extern "C" {
    #[doc = " Set the current filter. This is almost as expensive as recreating the shape. This may cause\n contacts to be immediately destroyed. However contacts are not created until the next world step.\n Sensor overlap state is also not updated until the next world step.\n @see b2ShapeDef::filter"]
    pub fn b2Shape_SetFilter(shapeId: b2ShapeId, filter: b2Filter);
}
unsafe extern "C" {
    #[doc = " Enable sensor events for this shape.\n @see b2ShapeDef::enableSensorEvents"]
    pub fn b2Shape_EnableSensorEvents(shapeId: b2ShapeId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if sensor events are enabled."]
    pub fn b2Shape_AreSensorEventsEnabled(shapeId: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.\n @see b2ShapeDef::enableContactEvents\n @warning changing this at run-time may lead to lost begin/end events"]
    pub fn b2Shape_EnableContactEvents(shapeId: b2ShapeId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if contact events are enabled"]
    pub fn b2Shape_AreContactEventsEnabled(shapeId: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive\n and must be carefully handled due to multithreading. Ignored for sensors.\n @see b2PreSolveFcn"]
    pub fn b2Shape_EnablePreSolveEvents(shapeId: b2ShapeId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if pre-solve events are enabled"]
    pub fn b2Shape_ArePreSolveEventsEnabled(shapeId: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Enable contact hit events for this shape. Ignored for sensors.\n @see b2WorldDef.hitEventThreshold"]
    pub fn b2Shape_EnableHitEvents(shapeId: b2ShapeId, flag: bool);
}
unsafe extern "C" {
    #[doc = " Returns true if hit events are enabled"]
    pub fn b2Shape_AreHitEventsEnabled(shapeId: b2ShapeId) -> bool;
}
unsafe extern "C" {
    #[doc = " Test a point for overlap with a shape"]
    pub fn b2Shape_TestPoint(shapeId: b2ShapeId, point: b2Vec2) -> bool;
}
unsafe extern "C" {
    #[doc = " Ray cast a shape directly"]
    pub fn b2Shape_RayCast(shapeId: b2ShapeId, input: *const b2RayCastInput) -> b2CastOutput;
}
unsafe extern "C" {
    #[doc = " Get a copy of the shape's circle. Asserts the type is correct."]
    pub fn b2Shape_GetCircle(shapeId: b2ShapeId) -> b2Circle;
}
unsafe extern "C" {
    #[doc = " Get a copy of the shape's line segment. Asserts the type is correct."]
    pub fn b2Shape_GetSegment(shapeId: b2ShapeId) -> b2Segment;
}
unsafe extern "C" {
    #[doc = " Get a copy of the shape's chain segment. These come from chain shapes.\n Asserts the type is correct."]
    pub fn b2Shape_GetChainSegment(shapeId: b2ShapeId) -> b2ChainSegment;
}
unsafe extern "C" {
    #[doc = " Get a copy of the shape's capsule. Asserts the type is correct."]
    pub fn b2Shape_GetCapsule(shapeId: b2ShapeId) -> b2Capsule;
}
unsafe extern "C" {
    #[doc = " Get a copy of the shape's convex polygon. Asserts the type is correct."]
    pub fn b2Shape_GetPolygon(shapeId: b2ShapeId) -> b2Polygon;
}
unsafe extern "C" {
    #[doc = " Allows you to change a shape to be a circle or update the current circle.\n This does not modify the mass properties.\n @see b2Body_ApplyMassFromShapes"]
    pub fn b2Shape_SetCircle(shapeId: b2ShapeId, circle: *const b2Circle);
}
unsafe extern "C" {
    #[doc = " Allows you to change a shape to be a capsule or update the current capsule.\n This does not modify the mass properties.\n @see b2Body_ApplyMassFromShapes"]
    pub fn b2Shape_SetCapsule(shapeId: b2ShapeId, capsule: *const b2Capsule);
}
unsafe extern "C" {
    #[doc = " Allows you to change a shape to be a segment or update the current segment."]
    pub fn b2Shape_SetSegment(shapeId: b2ShapeId, segment: *const b2Segment);
}
unsafe extern "C" {
    #[doc = " Allows you to change a shape to be a polygon or update the current polygon.\n This does not modify the mass properties.\n @see b2Body_ApplyMassFromShapes"]
    pub fn b2Shape_SetPolygon(shapeId: b2ShapeId, polygon: *const b2Polygon);
}
unsafe extern "C" {
    #[doc = " Get the parent chain id if the shape type is a chain segment, otherwise\n returns b2_nullChainId."]
    pub fn b2Shape_GetParentChain(shapeId: b2ShapeId) -> b2ChainId;
}
unsafe extern "C" {
    #[doc = " Get the maximum capacity required for retrieving all the touching contacts on a shape"]
    pub fn b2Shape_GetContactCapacity(shapeId: b2ShapeId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.\n @note Box2D uses speculative collision so some contact points may be separated.\n @returns the number of elements filled in the provided array\n @warning do not ignore the return value, it specifies the valid number of elements"]
    pub fn b2Shape_GetContactData(
        shapeId: b2ShapeId,
        contactData: *mut b2ContactData,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the maximum capacity required for retrieving all the overlapped shapes on a sensor shape.\n This returns 0 if the provided shape is not a sensor.\n @param shapeId the id of a sensor shape\n @returns the required capacity to get all the overlaps in b2Shape_GetSensorOverlaps"]
    pub fn b2Shape_GetSensorCapacity(shapeId: b2ShapeId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the overlap data for a sensor shape.\n @param shapeId the id of a sensor shape\n @param visitorIds a user allocated array that is filled with the overlapping shapes (visitors)\n @param capacity the capacity of overlappedShapes\n @returns the number of elements filled in the provided array\n @warning do not ignore the return value, it specifies the valid number of elements\n @warning overlaps may contain destroyed shapes so use b2Shape_IsValid to confirm each overlap"]
    pub fn b2Shape_GetSensorData(
        shapeId: b2ShapeId,
        visitorIds: *mut b2ShapeId,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the current world AABB"]
    pub fn b2Shape_GetAABB(shapeId: b2ShapeId) -> b2AABB;
}
unsafe extern "C" {
    #[doc = " Compute the mass data for a shape"]
    pub fn b2Shape_ComputeMassData(shapeId: b2ShapeId) -> b2MassData;
}
unsafe extern "C" {
    #[doc = " Get the closest point on a shape to a target point. Target and result are in world space.\n todo need sample"]
    pub fn b2Shape_GetClosestPoint(shapeId: b2ShapeId, target: b2Vec2) -> b2Vec2;
}
unsafe extern "C" {
    pub fn b2Shape_ApplyWindForce(
        shapeId: b2ShapeId,
        wind: b2Vec2,
        drag: f32,
        lift: f32,
        wake: bool,
    );
}
unsafe extern "C" {
    #[doc = " Create a chain shape\n @see b2ChainDef for details"]
    pub fn b2CreateChain(bodyId: b2BodyId, def: *const b2ChainDef) -> b2ChainId;
}
unsafe extern "C" {
    #[doc = " Destroy a chain shape"]
    pub fn b2DestroyChain(chainId: b2ChainId);
}
unsafe extern "C" {
    #[doc = " Get the world that owns this chain shape"]
    pub fn b2Chain_GetWorld(chainId: b2ChainId) -> b2WorldId;
}
unsafe extern "C" {
    #[doc = " Get the number of segments on this chain"]
    pub fn b2Chain_GetSegmentCount(chainId: b2ChainId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Fill a user array with chain segment shape ids up to the specified capacity. Returns\n the actual number of segments returned."]
    pub fn b2Chain_GetSegments(
        chainId: b2ChainId,
        segmentArray: *mut b2ShapeId,
        capacity: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Get the number of materials used on this chain. Must be 1 or the number of segments."]
    pub fn b2Chain_GetSurfaceMaterialCount(chainId: b2ChainId) -> ::std::os::raw::c_int;
}
unsafe extern "C" {
    #[doc = " Set a chain material. If the chain has only one material, this material is applied to all\n segments. Otherwise it is applied to a single segment."]
    pub fn b2Chain_SetSurfaceMaterial(
        chainId: b2ChainId,
        material: *const b2SurfaceMaterial,
        materialIndex: ::std::os::raw::c_int,
    );
}
unsafe extern "C" {
    #[doc = " Get a chain material by index."]
    pub fn b2Chain_GetSurfaceMaterial(
        chainId: b2ChainId,
        materialIndex: ::std::os::raw::c_int,
    ) -> b2SurfaceMaterial;
}
unsafe extern "C" {
    #[doc = " Chain identifier validation. Provides validation for up to 64K allocations."]
    pub fn b2Chain_IsValid(id: b2ChainId) -> bool;
}
unsafe extern "C" {
    #[doc = " Destroy a joint. Optionally wake attached bodies."]
    pub fn b2DestroyJoint(jointId: b2JointId, wakeAttached: bool);
}
unsafe extern "C" {
    #[doc = " Joint identifier validation. Provides validation for up to 64K allocations."]
    pub fn b2Joint_IsValid(id: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the joint type"]
    pub fn b2Joint_GetType(jointId: b2JointId) -> b2JointType;
}
unsafe extern "C" {
    #[doc = " Get body A id on a joint"]
    pub fn b2Joint_GetBodyA(jointId: b2JointId) -> b2BodyId;
}
unsafe extern "C" {
    #[doc = " Get body B id on a joint"]
    pub fn b2Joint_GetBodyB(jointId: b2JointId) -> b2BodyId;
}
unsafe extern "C" {
    #[doc = " Get the world that owns this joint"]
    pub fn b2Joint_GetWorld(jointId: b2JointId) -> b2WorldId;
}
unsafe extern "C" {
    #[doc = " Set the local frame on bodyA"]
    pub fn b2Joint_SetLocalFrameA(jointId: b2JointId, localFrame: b2Transform);
}
unsafe extern "C" {
    #[doc = " Get the local frame on bodyA"]
    pub fn b2Joint_GetLocalFrameA(jointId: b2JointId) -> b2Transform;
}
unsafe extern "C" {
    #[doc = " Set the local frame on bodyB"]
    pub fn b2Joint_SetLocalFrameB(jointId: b2JointId, localFrame: b2Transform);
}
unsafe extern "C" {
    #[doc = " Get the local frame on bodyB"]
    pub fn b2Joint_GetLocalFrameB(jointId: b2JointId) -> b2Transform;
}
unsafe extern "C" {
    #[doc = " Toggle collision between connected bodies"]
    pub fn b2Joint_SetCollideConnected(jointId: b2JointId, shouldCollide: bool);
}
unsafe extern "C" {
    #[doc = " Is collision allowed between connected bodies?"]
    pub fn b2Joint_GetCollideConnected(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the user data on a joint"]
    pub fn b2Joint_SetUserData(jointId: b2JointId, userData: *mut ::std::os::raw::c_void);
}
unsafe extern "C" {
    #[doc = " Get the user data on a joint"]
    pub fn b2Joint_GetUserData(jointId: b2JointId) -> *mut ::std::os::raw::c_void;
}
unsafe extern "C" {
    #[doc = " Wake the bodies connect to this joint"]
    pub fn b2Joint_WakeBodies(jointId: b2JointId);
}
unsafe extern "C" {
    #[doc = " Get the current constraint force for this joint. Usually in Newtons."]
    pub fn b2Joint_GetConstraintForce(jointId: b2JointId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Get the current constraint torque for this joint. Usually in Newton * meters."]
    pub fn b2Joint_GetConstraintTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current linear separation error for this joint. Does not consider admissible movement. Usually in meters."]
    pub fn b2Joint_GetLinearSeparation(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current angular separation error for this joint. Does not consider admissible movement. Usually in meters."]
    pub fn b2Joint_GetAngularSeparation(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the joint constraint tuning. Advanced feature.\n @param jointId the joint\n @param hertz the stiffness in Hertz (cycles per second)\n @param dampingRatio the non-dimensional damping ratio (one for critical damping)"]
    pub fn b2Joint_SetConstraintTuning(jointId: b2JointId, hertz: f32, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the joint constraint tuning. Advanced feature."]
    pub fn b2Joint_GetConstraintTuning(jointId: b2JointId, hertz: *mut f32, dampingRatio: *mut f32);
}
unsafe extern "C" {
    #[doc = " Set the force threshold for joint events (Newtons)"]
    pub fn b2Joint_SetForceThreshold(jointId: b2JointId, threshold: f32);
}
unsafe extern "C" {
    #[doc = " Get the force threshold for joint events (Newtons)"]
    pub fn b2Joint_GetForceThreshold(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the torque threshold for joint events (N-m)"]
    pub fn b2Joint_SetTorqueThreshold(jointId: b2JointId, threshold: f32);
}
unsafe extern "C" {
    #[doc = " Get the torque threshold for joint events (N-m)"]
    pub fn b2Joint_GetTorqueThreshold(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a distance joint\n @see b2DistanceJointDef for details"]
    pub fn b2CreateDistanceJoint(worldId: b2WorldId, def: *const b2DistanceJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Set the rest length of a distance joint\n @param jointId The id for a distance joint\n @param length The new distance joint length"]
    pub fn b2DistanceJoint_SetLength(jointId: b2JointId, length: f32);
}
unsafe extern "C" {
    #[doc = " Get the rest length of a distance joint"]
    pub fn b2DistanceJoint_GetLength(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable the distance joint spring. When disabled the distance joint is rigid."]
    pub fn b2DistanceJoint_EnableSpring(jointId: b2JointId, enableSpring: bool);
}
unsafe extern "C" {
    #[doc = " Is the distance joint spring enabled?"]
    pub fn b2DistanceJoint_IsSpringEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the force range for the spring."]
    pub fn b2DistanceJoint_SetSpringForceRange(
        jointId: b2JointId,
        lowerForce: f32,
        upperForce: f32,
    );
}
unsafe extern "C" {
    #[doc = " Get the force range for the spring."]
    pub fn b2DistanceJoint_GetSpringForceRange(
        jointId: b2JointId,
        lowerForce: *mut f32,
        upperForce: *mut f32,
    );
}
unsafe extern "C" {
    #[doc = " Set the spring stiffness in Hertz"]
    pub fn b2DistanceJoint_SetSpringHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Set the spring damping ratio, non-dimensional"]
    pub fn b2DistanceJoint_SetSpringDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the spring Hertz"]
    pub fn b2DistanceJoint_GetSpringHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the spring damping ratio"]
    pub fn b2DistanceJoint_GetSpringDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable joint limit. The limit only works if the joint spring is enabled. Otherwise the joint is rigid\n and the limit has no effect."]
    pub fn b2DistanceJoint_EnableLimit(jointId: b2JointId, enableLimit: bool);
}
unsafe extern "C" {
    #[doc = " Is the distance joint limit enabled?"]
    pub fn b2DistanceJoint_IsLimitEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the minimum and maximum length parameters of a distance joint"]
    pub fn b2DistanceJoint_SetLengthRange(jointId: b2JointId, minLength: f32, maxLength: f32);
}
unsafe extern "C" {
    #[doc = " Get the distance joint minimum length"]
    pub fn b2DistanceJoint_GetMinLength(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the distance joint maximum length"]
    pub fn b2DistanceJoint_GetMaxLength(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current length of a distance joint"]
    pub fn b2DistanceJoint_GetCurrentLength(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable the distance joint motor"]
    pub fn b2DistanceJoint_EnableMotor(jointId: b2JointId, enableMotor: bool);
}
unsafe extern "C" {
    #[doc = " Is the distance joint motor enabled?"]
    pub fn b2DistanceJoint_IsMotorEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the distance joint motor speed, usually in meters per second"]
    pub fn b2DistanceJoint_SetMotorSpeed(jointId: b2JointId, motorSpeed: f32);
}
unsafe extern "C" {
    #[doc = " Get the distance joint motor speed, usually in meters per second"]
    pub fn b2DistanceJoint_GetMotorSpeed(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the distance joint maximum motor force, usually in newtons"]
    pub fn b2DistanceJoint_SetMaxMotorForce(jointId: b2JointId, force: f32);
}
unsafe extern "C" {
    #[doc = " Get the distance joint maximum motor force, usually in newtons"]
    pub fn b2DistanceJoint_GetMaxMotorForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the distance joint current motor force, usually in newtons"]
    pub fn b2DistanceJoint_GetMotorForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a motor joint\n @see b2MotorJointDef for details"]
    pub fn b2CreateMotorJoint(worldId: b2WorldId, def: *const b2MotorJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Set the desired relative linear velocity in meters per second"]
    pub fn b2MotorJoint_SetLinearVelocity(jointId: b2JointId, velocity: b2Vec2);
}
unsafe extern "C" {
    #[doc = " Get the desired relative linear velocity in meters per second"]
    pub fn b2MotorJoint_GetLinearVelocity(jointId: b2JointId) -> b2Vec2;
}
unsafe extern "C" {
    #[doc = " Set the desired relative angular velocity in radians per second"]
    pub fn b2MotorJoint_SetAngularVelocity(jointId: b2JointId, velocity: f32);
}
unsafe extern "C" {
    #[doc = " Get the desired relative angular velocity in radians per second"]
    pub fn b2MotorJoint_GetAngularVelocity(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the motor joint maximum force, usually in newtons"]
    pub fn b2MotorJoint_SetMaxVelocityForce(jointId: b2JointId, maxForce: f32);
}
unsafe extern "C" {
    #[doc = " Get the motor joint maximum force, usually in newtons"]
    pub fn b2MotorJoint_GetMaxVelocityForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the motor joint maximum torque, usually in newton-meters"]
    pub fn b2MotorJoint_SetMaxVelocityTorque(jointId: b2JointId, maxTorque: f32);
}
unsafe extern "C" {
    #[doc = " Get the motor joint maximum torque, usually in newton-meters"]
    pub fn b2MotorJoint_GetMaxVelocityTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the spring linear hertz stiffness"]
    pub fn b2MotorJoint_SetLinearHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the spring linear hertz stiffness"]
    pub fn b2MotorJoint_GetLinearHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the spring linear damping ratio. Use 1.0 for critical damping."]
    pub fn b2MotorJoint_SetLinearDampingRatio(jointId: b2JointId, damping: f32);
}
unsafe extern "C" {
    #[doc = " Get the spring linear damping ratio."]
    pub fn b2MotorJoint_GetLinearDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the spring angular hertz stiffness"]
    pub fn b2MotorJoint_SetAngularHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the spring angular hertz stiffness"]
    pub fn b2MotorJoint_GetAngularHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the spring angular damping ratio. Use 1.0 for critical damping."]
    pub fn b2MotorJoint_SetAngularDampingRatio(jointId: b2JointId, damping: f32);
}
unsafe extern "C" {
    #[doc = " Get the spring angular damping ratio."]
    pub fn b2MotorJoint_GetAngularDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the maximum spring force in newtons."]
    pub fn b2MotorJoint_SetMaxSpringForce(jointId: b2JointId, maxForce: f32);
}
unsafe extern "C" {
    #[doc = " Get the maximum spring force in newtons."]
    pub fn b2MotorJoint_GetMaxSpringForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the maximum spring torque in newtons * meters"]
    pub fn b2MotorJoint_SetMaxSpringTorque(jointId: b2JointId, maxTorque: f32);
}
unsafe extern "C" {
    #[doc = " Get the maximum spring torque in newtons * meters"]
    pub fn b2MotorJoint_GetMaxSpringTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a filter joint.\n @see b2FilterJointDef for details"]
    pub fn b2CreateFilterJoint(worldId: b2WorldId, def: *const b2FilterJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Create a prismatic (slider) joint.\n @see b2PrismaticJointDef for details"]
    pub fn b2CreatePrismaticJoint(worldId: b2WorldId, def: *const b2PrismaticJointDef)
    -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Enable/disable the joint spring."]
    pub fn b2PrismaticJoint_EnableSpring(jointId: b2JointId, enableSpring: bool);
}
unsafe extern "C" {
    #[doc = " Is the prismatic joint spring enabled or not?"]
    pub fn b2PrismaticJoint_IsSpringEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint stiffness in Hertz.\n This should usually be less than a quarter of the simulation rate. For example, if the simulation\n runs at 60Hz then the joint stiffness should be 15Hz or less."]
    pub fn b2PrismaticJoint_SetSpringHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint stiffness in Hertz"]
    pub fn b2PrismaticJoint_GetSpringHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint damping ratio (non-dimensional)"]
    pub fn b2PrismaticJoint_SetSpringDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the prismatic spring damping ratio (non-dimensional)"]
    pub fn b2PrismaticJoint_GetSpringDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint spring target angle, usually in meters"]
    pub fn b2PrismaticJoint_SetTargetTranslation(jointId: b2JointId, translation: f32);
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint spring target translation, usually in meters"]
    pub fn b2PrismaticJoint_GetTargetTranslation(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable a prismatic joint limit"]
    pub fn b2PrismaticJoint_EnableLimit(jointId: b2JointId, enableLimit: bool);
}
unsafe extern "C" {
    #[doc = " Is the prismatic joint limit enabled?"]
    pub fn b2PrismaticJoint_IsLimitEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint lower limit"]
    pub fn b2PrismaticJoint_GetLowerLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint upper limit"]
    pub fn b2PrismaticJoint_GetUpperLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint limits"]
    pub fn b2PrismaticJoint_SetLimits(jointId: b2JointId, lower: f32, upper: f32);
}
unsafe extern "C" {
    #[doc = " Enable/disable a prismatic joint motor"]
    pub fn b2PrismaticJoint_EnableMotor(jointId: b2JointId, enableMotor: bool);
}
unsafe extern "C" {
    #[doc = " Is the prismatic joint motor enabled?"]
    pub fn b2PrismaticJoint_IsMotorEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint motor speed, usually in meters per second"]
    pub fn b2PrismaticJoint_SetMotorSpeed(jointId: b2JointId, motorSpeed: f32);
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint motor speed, usually in meters per second"]
    pub fn b2PrismaticJoint_GetMotorSpeed(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the prismatic joint maximum motor force, usually in newtons"]
    pub fn b2PrismaticJoint_SetMaxMotorForce(jointId: b2JointId, force: f32);
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint maximum motor force, usually in newtons"]
    pub fn b2PrismaticJoint_GetMaxMotorForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the prismatic joint current motor force, usually in newtons"]
    pub fn b2PrismaticJoint_GetMotorForce(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current joint translation, usually in meters."]
    pub fn b2PrismaticJoint_GetTranslation(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the current joint translation speed, usually in meters per second."]
    pub fn b2PrismaticJoint_GetSpeed(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a revolute joint\n @see b2RevoluteJointDef for details"]
    pub fn b2CreateRevoluteJoint(worldId: b2WorldId, def: *const b2RevoluteJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Enable/disable the revolute joint spring"]
    pub fn b2RevoluteJoint_EnableSpring(jointId: b2JointId, enableSpring: bool);
}
unsafe extern "C" {
    #[doc = " It the revolute angular spring enabled?"]
    pub fn b2RevoluteJoint_IsSpringEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint spring stiffness in Hertz"]
    pub fn b2RevoluteJoint_SetSpringHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the revolute joint spring stiffness in Hertz"]
    pub fn b2RevoluteJoint_GetSpringHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint spring damping ratio, non-dimensional"]
    pub fn b2RevoluteJoint_SetSpringDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the revolute joint spring damping ratio, non-dimensional"]
    pub fn b2RevoluteJoint_GetSpringDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint spring target angle, radians"]
    pub fn b2RevoluteJoint_SetTargetAngle(jointId: b2JointId, angle: f32);
}
unsafe extern "C" {
    #[doc = " Get the revolute joint spring target angle, radians"]
    pub fn b2RevoluteJoint_GetTargetAngle(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the revolute joint current angle in radians relative to the reference angle\n @see b2RevoluteJointDef::referenceAngle"]
    pub fn b2RevoluteJoint_GetAngle(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable the revolute joint limit"]
    pub fn b2RevoluteJoint_EnableLimit(jointId: b2JointId, enableLimit: bool);
}
unsafe extern "C" {
    #[doc = " Is the revolute joint limit enabled?"]
    pub fn b2RevoluteJoint_IsLimitEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the revolute joint lower limit in radians"]
    pub fn b2RevoluteJoint_GetLowerLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the revolute joint upper limit in radians"]
    pub fn b2RevoluteJoint_GetUpperLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint limits in radians. It is expected that lower <= upper\n and that -0.99 * B2_PI <= lower && upper <= -0.99 * B2_PI."]
    pub fn b2RevoluteJoint_SetLimits(jointId: b2JointId, lower: f32, upper: f32);
}
unsafe extern "C" {
    #[doc = " Enable/disable a revolute joint motor"]
    pub fn b2RevoluteJoint_EnableMotor(jointId: b2JointId, enableMotor: bool);
}
unsafe extern "C" {
    #[doc = " Is the revolute joint motor enabled?"]
    pub fn b2RevoluteJoint_IsMotorEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint motor speed in radians per second"]
    pub fn b2RevoluteJoint_SetMotorSpeed(jointId: b2JointId, motorSpeed: f32);
}
unsafe extern "C" {
    #[doc = " Get the revolute joint motor speed in radians per second"]
    pub fn b2RevoluteJoint_GetMotorSpeed(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the revolute joint current motor torque, usually in newton-meters"]
    pub fn b2RevoluteJoint_GetMotorTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the revolute joint maximum motor torque, usually in newton-meters"]
    pub fn b2RevoluteJoint_SetMaxMotorTorque(jointId: b2JointId, torque: f32);
}
unsafe extern "C" {
    #[doc = " Get the revolute joint maximum motor torque, usually in newton-meters"]
    pub fn b2RevoluteJoint_GetMaxMotorTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a weld joint\n @see b2WeldJointDef for details"]
    pub fn b2CreateWeldJoint(worldId: b2WorldId, def: *const b2WeldJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Set the weld joint linear stiffness in Hertz. 0 is rigid."]
    pub fn b2WeldJoint_SetLinearHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the weld joint linear stiffness in Hertz"]
    pub fn b2WeldJoint_GetLinearHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the weld joint linear damping ratio (non-dimensional)"]
    pub fn b2WeldJoint_SetLinearDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the weld joint linear damping ratio (non-dimensional)"]
    pub fn b2WeldJoint_GetLinearDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the weld joint angular stiffness in Hertz. 0 is rigid."]
    pub fn b2WeldJoint_SetAngularHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the weld joint angular stiffness in Hertz"]
    pub fn b2WeldJoint_GetAngularHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set weld joint angular damping ratio, non-dimensional"]
    pub fn b2WeldJoint_SetAngularDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the weld joint angular damping ratio, non-dimensional"]
    pub fn b2WeldJoint_GetAngularDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Create a wheel joint\n @see b2WheelJointDef for details"]
    pub fn b2CreateWheelJoint(worldId: b2WorldId, def: *const b2WheelJointDef) -> b2JointId;
}
unsafe extern "C" {
    #[doc = " Enable/disable the wheel joint spring"]
    pub fn b2WheelJoint_EnableSpring(jointId: b2JointId, enableSpring: bool);
}
unsafe extern "C" {
    #[doc = " Is the wheel joint spring enabled?"]
    pub fn b2WheelJoint_IsSpringEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the wheel joint stiffness in Hertz"]
    pub fn b2WheelJoint_SetSpringHertz(jointId: b2JointId, hertz: f32);
}
unsafe extern "C" {
    #[doc = " Get the wheel joint stiffness in Hertz"]
    pub fn b2WheelJoint_GetSpringHertz(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the wheel joint damping ratio, non-dimensional"]
    pub fn b2WheelJoint_SetSpringDampingRatio(jointId: b2JointId, dampingRatio: f32);
}
unsafe extern "C" {
    #[doc = " Get the wheel joint damping ratio, non-dimensional"]
    pub fn b2WheelJoint_GetSpringDampingRatio(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Enable/disable the wheel joint limit"]
    pub fn b2WheelJoint_EnableLimit(jointId: b2JointId, enableLimit: bool);
}
unsafe extern "C" {
    #[doc = " Is the wheel joint limit enabled?"]
    pub fn b2WheelJoint_IsLimitEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the wheel joint lower limit"]
    pub fn b2WheelJoint_GetLowerLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the wheel joint upper limit"]
    pub fn b2WheelJoint_GetUpperLimit(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the wheel joint limits"]
    pub fn b2WheelJoint_SetLimits(jointId: b2JointId, lower: f32, upper: f32);
}
unsafe extern "C" {
    #[doc = " Enable/disable the wheel joint motor"]
    pub fn b2WheelJoint_EnableMotor(jointId: b2JointId, enableMotor: bool);
}
unsafe extern "C" {
    #[doc = " Is the wheel joint motor enabled?"]
    pub fn b2WheelJoint_IsMotorEnabled(jointId: b2JointId) -> bool;
}
unsafe extern "C" {
    #[doc = " Set the wheel joint motor speed in radians per second"]
    pub fn b2WheelJoint_SetMotorSpeed(jointId: b2JointId, motorSpeed: f32);
}
unsafe extern "C" {
    #[doc = " Get the wheel joint motor speed in radians per second"]
    pub fn b2WheelJoint_GetMotorSpeed(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Set the wheel joint maximum motor torque, usually in newton-meters"]
    pub fn b2WheelJoint_SetMaxMotorTorque(jointId: b2JointId, torque: f32);
}
unsafe extern "C" {
    #[doc = " Get the wheel joint maximum motor torque, usually in newton-meters"]
    pub fn b2WheelJoint_GetMaxMotorTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Get the wheel joint current motor torque, usually in newton-meters"]
    pub fn b2WheelJoint_GetMotorTorque(jointId: b2JointId) -> f32;
}
unsafe extern "C" {
    #[doc = " Contact identifier validation. Provides validation for up to 2^32 allocations."]
    pub fn b2Contact_IsValid(id: b2ContactId) -> bool;
}
unsafe extern "C" {
    #[doc = " Get the data for a contact. The manifold may have no points if the contact is not touching."]
    pub fn b2Contact_GetData(contactId: b2ContactId) -> b2ContactData;
}
#[doc = " The tree nodes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct b2TreeNode {
    pub _address: u8,
}
